<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java快速入门 | 王延领的博客</title><meta name="keywords" content="从net到java,王延领"><meta name="author" content="王延领"><meta name="copyright" content="王延领"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java学习笔记-从net到java">
<meta property="og:type" content="article">
<meta property="og:title" content="java快速入门">
<meta property="og:url" content="http://jingmo1924.cn/2021/09/06/java/firststage/java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="王延领的博客">
<meta property="og:description" content="java学习笔记-从net到java">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jingmo1924.cn/images/20210903145511.png">
<meta property="article:published_time" content="2021-09-06T03:11:51.048Z">
<meta property="article:modified_time" content="2022-06-17T06:44:07.192Z">
<meta property="article:author" content="王延领">
<meta property="article:tag" content="从net到java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jingmo1924.cn/images/20210903145511.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jingmo1924.cn/2021/09/06/java/firststage/java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-17 14:44:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/20210903145511.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">王延领的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java快速入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-06T03:11:51.048Z" title="发表于 2021-09-06 11:11:51">2021-09-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-17T06:44:07.192Z" title="更新于 2022-06-17 14:44:07">2022-06-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BB%8Enet%E5%88%B0java/">从net到java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java快速入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h1><p>注释的重要性不言而喻，我们不管写什么代码注释必不可少，那么java的注释的书写方式与注释模板是怎么进行的呢？我们来看一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> frist;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description HelloWorld类</span></span><br><span class="line"><span class="comment"> * @Author 王延领</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这是我们Java程序的主入口，</span></span><br><span class="line"><span class="comment">    main方法也是程序的主线程。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">       System.out.println(<span class="string">&quot;wyl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.1 注释<br>以上可以看出java的注释主要有三种<br>单行注释：只能注释当前行，以//开始，直到行结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;输出</span><br></pre></td></tr></table></figure>
<p>多行注释：注释一段文字，以/*开始， */结束！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   这是我们Java程序的主入口，</span><br><span class="line">   main方法也是程序的主线程。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<p>文档注释：用于生产API文档，配合JavaDoc。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * @Description HelloWorld类</span><br><span class="line"> * @Author 王延领</span><br><span class="line"> **&#x2F;</span><br></pre></td></tr></table></figure>
<p>1.2 idea注释模版配置<br>1.2.1 定义java文件头部的注释<br>File =&gt; setting =&gt; editor =&gt;  File and Code Templates-class -Includes<br><img src="/images/img/blog/image-20210712143531809.png" alt="image-20210712143531809"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * @创建人 王延领</span><br><span class="line">  *@创建时间 $&#123;DATE&#125;</span><br><span class="line">  *描述 Todo</span><br><span class="line">**&#x2F;</span><br></pre></td></tr></table></figure>
<p>以上当你创建一个class的时候就会带上以上信息了<br>1.2.2 给java类中的方法添加上注释<br>第一步勾选Enable Live  Templates<br>首先要在上一步中勾选中 Enable  Live  Templates<br><img src="/images/img/blog/image-20210712144107882.png" alt="image-20210712144107882"><br>第二步新建一个Group<br>其次要打开LiveTemplates 然后新建一个Group<br>如图：<br><img src="/images/img/blog/2018082910142321.png" alt="img"><br>在弹窗口中输入你想要的group名称，wyl<br><img src="/images/img/blog/image-20210712144433114.png" alt="image-20210712144433114"><br>其中：Abbreviation 为快捷键,当输入w的时候就会提示对应的方法注释模板，j为类的注释模板<br><img src="/images/img/blog/image-20210712144649673.png" alt="image-20210712144649673"><br>Templete Text<br>注释内容，$$ 为动态模板参数点击Edit Vaariables 选择对应动态值。</p>
<p><img src="/images/img/blog/image-20210712144955611.png" alt="image-20210712144955611"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *@描述 TODO</span></span><br><span class="line"><span class="comment"> *@作者 王延领</span></span><br><span class="line"><span class="comment"> *@时间 2021/7/12</span></span><br><span class="line"><span class="comment"> *@版本 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wyl</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *@描述</span></span><br><span class="line"><span class="comment">     *@参数 [str]</span></span><br><span class="line"><span class="comment">     *@返回值 [java.lang.String]</span></span><br><span class="line"><span class="comment">     *@创建人 王延领</span></span><br><span class="line"><span class="comment">     *@创建时间 2021/7/12</span></span><br><span class="line"><span class="comment">     *@修改人和其它信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CommentTemplate</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2.关键字"></a>2.关键字</h1><table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>一种访问控制方式：私用模式</td>
</tr>
<tr>
<td>protected</td>
<td>一种访问控制方式：保护模式</td>
</tr>
<tr>
<td>public</td>
<td>一种访问控制方式：共用模式</td>
</tr>
<tr>
<td>abstract</td>
<td>表明类或者成员方法具有抽象属性</td>
</tr>
<tr>
<td>class</td>
<td>类</td>
</tr>
<tr>
<td>extends</td>
<td>表明一个类型是另一个类型的子类型，这里常见的类型有类和接口</td>
</tr>
<tr>
<td>final</td>
<td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变</td>
</tr>
<tr>
<td>implements</td>
<td>表明一个类实现了给定的接口</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td>native</td>
<td>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td>
</tr>
<tr>
<td>new</td>
<td>用来创建新实例对象</td>
</tr>
<tr>
<td>static</td>
<td>表明具有静态属性</td>
</tr>
<tr>
<td>strictfp</td>
<td>用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</td>
</tr>
<tr>
<td>synchronized</td>
<td>表明一段代码需要同步执行</td>
</tr>
<tr>
<td>transient</td>
<td>声明不用序列化的成员域</td>
</tr>
<tr>
<td>volatile</td>
<td>表明两个或者多个变量必须同步地发生变化</td>
</tr>
<tr>
<td>break</td>
<td>提前跳出一个块</td>
</tr>
<tr>
<td>continue</td>
<td>回到一个块的开始处</td>
</tr>
<tr>
<td>return</td>
<td>从成员方法中返回数据</td>
</tr>
<tr>
<td>do</td>
<td>用在do-while循环结构中</td>
</tr>
<tr>
<td>while</td>
<td>用在循环结构中</td>
</tr>
<tr>
<td>if</td>
<td>条件语句的引导词</td>
</tr>
<tr>
<td>else</td>
<td>用在条件语句中，表明当条件不成立时的分支</td>
</tr>
<tr>
<td>for</td>
<td>一种循环结构的引导词</td>
</tr>
<tr>
<td>instanceof</td>
<td>用来测试一个对象是否是指定类型的实例对象</td>
</tr>
<tr>
<td>switch</td>
<td>分支语句结构的引导词</td>
</tr>
<tr>
<td>case</td>
<td>用在switch语句之中，表示其中的一个分支</td>
</tr>
<tr>
<td>default</td>
<td>默认，例如，用在switch语句中，表明一个默认的分支</td>
</tr>
<tr>
<td>try</td>
<td>尝试一个可能抛出异常的程序块</td>
</tr>
<tr>
<td>catch</td>
<td>用在异常处理中，用来捕捉异常</td>
</tr>
<tr>
<td>throw</td>
<td>抛出一个异常</td>
</tr>
<tr>
<td>throws</td>
<td>声明在当前定义的成员方法中所有需要抛出的异常</td>
</tr>
<tr>
<td>import</td>
<td>表明要访问指定的类或包</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
</tr>
<tr>
<td>boolean</td>
<td>基本数据类型之一，布尔类型</td>
</tr>
<tr>
<td>byte</td>
<td>基本数据类型之一，字节类型</td>
</tr>
<tr>
<td>char</td>
<td>基本数据类型之一，字符类型</td>
</tr>
<tr>
<td>double</td>
<td>基本数据类型之一，双精度浮点数类型</td>
</tr>
<tr>
<td>float</td>
<td>基本数据类型之一，单精度浮点数类型</td>
</tr>
<tr>
<td>int</td>
<td>基本数据类型之一，整数类型</td>
</tr>
<tr>
<td>long</td>
<td>基本数据类型之一，长整数类型</td>
</tr>
<tr>
<td>short</td>
<td>基本数据类型之一,短整数类型</td>
</tr>
<tr>
<td>super</td>
<td>表明当前对象的父类型的引用或者父类型的构造方法</td>
</tr>
<tr>
<td>this</td>
<td>指向当前实例对象的引用</td>
</tr>
<tr>
<td>void</td>
<td>声明当前成员方法没有返回值</td>
</tr>
<tr>
<td>goto</td>
<td>保留关键字，没有具体含义</td>
</tr>
<tr>
<td>const</td>
<td>保留关键字，没有具体含义</td>
</tr>
</tbody></table>
<h1 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h1><p><img src="/images/img/blog/image-20210712151302116.png" alt="image-20210712151302116">                </p>
<h2 id="3-1-数据类型转换"><a href="#3-1-数据类型转换" class="headerlink" title="3.1.数据类型转换"></a>3.1.数据类型转换</h2><h3 id="3-1-1自动类型转换"><a href="#3-1-1自动类型转换" class="headerlink" title="3.1.1自动类型转换"></a>3.1.1自动类型转换</h3><p>自动类型转换：容量小的数据类型可以自动转换为容量大的数据类型。<br><img src="/images/img/blog/image-20210712152354656.png" alt="image-20210712152354656"><br>注：如果低级类型为char型，向高级类型（整型）转换时，会转换为对应ASCII码值</p>
<h3 id="3-1-2-强制类型转换"><a href="#3-1-2-强制类型转换" class="headerlink" title="3.1.2 强制类型转换"></a>3.1.2 强制类型转换</h3><p>强制类型转换，又被称为造型，用于显式的转换一个数值的类型.<br>转换方式为：(type)var ，运算符“()”中的type表示将值var想要转换成的目标数据类型。 条件是转换的数据类型必须是兼容的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> nx = (<span class="keyword">int</span>)x; <span class="comment">//值为3</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> d = c+<span class="number">1</span>;</span><br><span class="line">System.out.println(d); <span class="comment">//98</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>)d); <span class="comment">//b</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-3-包装类过渡类型转换"><a href="#3-1-3-包装类过渡类型转换" class="headerlink" title="3.1.3.包装类过渡类型转换"></a>3.1.3.包装类过渡类型转换</h3><p>eg1:int i=Integer.parseInt(“123”)<br>说明：此方法只能适用于字符串转化成整型变量<br>eg2: float f=Float.valueOf(“123”).floatValue()<br>说明：上例是将一个字符串转化成一个Float对象，然后再调用这个对象的floatValue()方法返回其对应的float数值。<br>eg3: boolean b=Boolean.valueOf(“123”).booleanValue()<br>说明：上例是将一个字符串转化成一个Boolean对象，然后再调用这个对象的booleanValue()方法返回其对应的boolean数值。<br>eg4:double d=Double.valueOf(“123”).doublue()<br>说明：上例是将一个字符串转化成一个Double对象，然后再调用这个对象的doublue()方法返回其对应的double数值。<br>eg5: long l=Long.valueOf(“123”).longValue()<br>说明：上例是将一个字符串转化成一个Long对象，然后再调用这个对象的longValue()方法返回其对应的long数值。<br>eg6: char=Character.valueOf(“123”).charValue()<br>说明：上例是将一个字符串转化成一个Character对象</p>
<h1 id="4-常量、变量、运算符"><a href="#4-常量、变量、运算符" class="headerlink" title="4.常量、变量、运算符"></a>4.常量、变量、运算符</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>变量是什么：就是可以变化的量！</strong><br>我们通过变量来操纵存储空间中的数据，变量就是指代这个存储空间！空间位置是确定的，但是里面放<br>置什么值不确定！Java是一种强类型语言，每个变量都必须声明其类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;数据类型 变量名 &#x3D; 值；可以使用逗号隔开来声明多个同类型变量。</span><br></pre></td></tr></table></figure>
<p>注意事项：<br>每个变量都有类型，类型可以是基本类型，也可以是引用类型。<br>变量名必须是合法的标识符。<br>变量声明是一条完整的语句，因此每一个声明都必须以分号结束<br><strong>变量作用域</strong><br>类变量（静态变量： static variable）：独立于方法之外的变量，用 static 修饰。<br>实例变量（成员变量：member variable）：独立于方法之外的变量，不过没有 static 修饰。<br>局部变量（lacal variable）：类的方法中的变量。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>常量(Constant)：初始化(initialize)后不能再改变值！不会变动的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 常量名=值;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> PI=<span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ol>
<li>所有变量、方法、类名：见名知意</li>
<li>类成员变量：首字母小写和驼峰原则 : monthSalary</li>
<li>局部变量：首字母小写和驼峰原则</li>
<li>常量：大写字母和下划线：MAX_VALUE</li>
<li>类名：首字母大写和驼峰原则: Man, GoodMan</li>
<li>方法名：首字母小写和驼峰原则: run(), runRun()<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2>Java 语言支持如下运算符：<br>算术运算符: +，-，<em>，/，%，++，–<br>赋值运算符 =<br>关系运算符: &gt;，&lt;，&gt;=，&lt;=，==，!= instanceof<br>逻辑运算符: &amp;&amp;，||，!<br>位运算符: &amp;，|，^，~ ， &gt;&gt;，&lt;&lt;，&gt;&gt;&gt; (了解！！！)<br>条件运算符 ？：<br>扩展赋值运算符:+=，-=，</em>=，/=<h1 id="5-java流转控制"><a href="#5-java流转控制" class="headerlink" title="5.java流转控制"></a>5.java流转控制</h1>if…else、while、do…while、for、switch…case 在这就不累述了。<br>跳转：<br>return<br>return从一个方法返回，并把控制权交给调用它的语句序；或者直接结束当前的程序；<br>break<br>break语句在for、while、do···while循环语句中，经常用于强行退出当前循环；<br>continue<br>continue语句用于跳过此次循环，执行下次循环；<h1 id="6-方法"><a href="#6-方法" class="headerlink" title="6.方法"></a>6.方法</h1></li>
</ol>
<p><strong>那么什么是方法呢？</strong><br>Java方法是语句的集合，它们在一起执行一个功能。<br>方法是解决一类问题的步骤的有序组合<br>方法包含于类或对象中<br>方法在程序中被创建，在其他地方被引用<br>设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最<br>好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。<br><strong>方法的优点</strong><br>使程序变得更简短而清晰。<br>有利于程序维护。<br>可以提高程序开发的效率。<br>提高了代码的重用性。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。<br><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需<br>的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。<br><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。<br><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参<br>数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。<br>    形式参数：在方法被调用时用于接收外界输入的数据。<br>    实参：调用方法时实际传给方法的数据。<br><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在方法声明中，在指定参数类型后加一个省略号(…) 。<br>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声<br>明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName... parameterName</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>自己调用自己</p>
<h1 id="7-数组"><a href="#7-数组" class="headerlink" title="7.数组"></a>7.数组</h1><h2 id="数组的定义："><a href="#数组的定义：" class="headerlink" title="数组的定义："></a>数组的定义：</h2><p>数组是相同类型数据的有序集合.<br>数组描述的是相同类型的若干个数据,按照一定的先后次序排列组合而成。<br>其中,每一个数据称作一个数组元素,每个数组元素可以通过一个下标来访问它们.</p>
<h2 id="数组的四个基本特点："><a href="#数组的四个基本特点：" class="headerlink" title="数组的四个基本特点："></a>数组的四个基本特点：</h2><ol>
<li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</li>
<li>其元素必须是相同类型,不允许出现混合类型。</li>
<li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li>
<li>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量<h2 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar; <span class="comment">// 首选的方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[]; <span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[<span class="number">1</span> arraySize];</span><br></pre></td></tr></table></figure>

<p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。</p>
<h2 id="三种初始化"><a href="#三种初始化" class="headerlink" title="三种初始化"></a>三种初始化</h2><p>静态初始化<br>除了用new关键字来产生数组以外,还可以直接在定义数组的同时就为数组元素分配空间并赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Man[] mans = &#123;<span class="keyword">new</span> Man(<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">new</span> Man(<span class="number">2</span>,<span class="number">2</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>动态初始化<br>数组定义、为数组元素分配空间、赋值的操作、分开进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>数组的默认初始化<br>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实<br>例变量同样的方式被隐式初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">boolean</span>[] b = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>];</span><br><span class="line">String[] s = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">System.out.println(a[<span class="number">0</span>]+<span class="string">&quot;:&quot;</span>+a[<span class="number">1</span>]); <span class="comment">//0,0</span></span><br><span class="line">System.out.println(b[<span class="number">0</span>]+<span class="string">&quot;:&quot;</span>+b[<span class="number">1</span>]); <span class="comment">//false,false</span></span><br><span class="line">System.out.println(s[<span class="number">0</span>]+<span class="string">&quot;:&quot;</span>+s[<span class="number">1</span>]); <span class="comment">//null, null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组边界"><a href="#数组边界" class="headerlink" title="数组边界"></a>数组边界</h2><p>下标的合法区间：[0, length-1]，如果越界就会报错；</p>
<h2 id="for-和For-Each-循环"><a href="#for-和For-Each-循环" class="headerlink" title="for 和For-Each 循环"></a>for 和For-Each 循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type element: array)&#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">System.out.println(myList[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[][] typeName = <span class="keyword">new</span> type[typeLength1][<span class="number">1</span> typeLength2];</span><br></pre></td></tr></table></figure>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>数组的工具类java.util.Arrays<br>java.util.Arrays 类能方便地操作数组. 使用之前需要导包！<br>具有以下常用功能：<br>给数组赋值：通过 fill 方法。<br>对数组排序：通过 sort 方法,按升序。<br>比较数组：通过 equals 方法比较数组中元素值是否相等。<br>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。<br>转换为list: 通过asList(a)进行转换</p>
<h1 id="8-面向对象"><a href="#8-面向对象" class="headerlink" title="8.面向对象"></a>8.面向对象</h1><p>万物皆为对象！！！对象是抽象概念的具体实例。</p>
<p>以类的方式组织代码，以对象的组织(封装)数据就是面向对象</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要继承，因为有重复。所以才继承，进而我们就知道了。父类就是公共部分的定义或规则</p>
<p> Java 不支持多继承（只能继承一个类），但支持多重继承。</p>
<p><img src="/images/img/blog/image-20210809181238809.png" alt="image-20210809181238809"></p>
<p>特点</p>
<ul>
<li><p>子类拥有父类非 private 的属性、方法。</p>
</li>
<li><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li><p>子类可以用自己的方式实现父类的方法。</p>
</li>
<li><p>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</p>
</li>
<li><p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）</p>
</li>
</ul>
<p><strong>super 与 this 关键字</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;animal : eat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;dog : eat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eatTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eat();   <span class="comment">// this 调用自己的方法</span></span><br><span class="line">    <span class="keyword">super</span>.eat();  <span class="comment">// super 调用父类方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">    a.eat();</span><br><span class="line">    Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">    d.eatTest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animal : eat</span><br><span class="line">dog : eat</span><br><span class="line">animal : eat</span><br></pre></td></tr></table></figure>
<p><strong>final关键字</strong><br>final 关键字声明类可以把类定义为不能继承的，即最终类；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">  SuperClass()&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SuperClass()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  SuperClass(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SuperClass(int n)&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubClass 类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">  </span><br><span class="line">  SubClass()&#123; <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(<span class="number">300</span>);  <span class="comment">// 调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass(int n):&quot;</span>+n);</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubClass2 类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">  </span><br><span class="line">  SubClass2()&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">300</span>);  <span class="comment">// 调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass2&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubClass2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass2(int n):&quot;</span>+n);</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuperSub</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------SubClass 类继承------&quot;</span>);</span><br><span class="line">    SubClass sc1 = <span class="keyword">new</span> SubClass();</span><br><span class="line">    SubClass sc2 = <span class="keyword">new</span> SubClass(<span class="number">100</span>); </span><br><span class="line">    System.out.println(<span class="string">&quot;------SubClass2 类继承------&quot;</span>);</span><br><span class="line">    SubClass2 sc3 = <span class="keyword">new</span> SubClass2();</span><br><span class="line">    SubClass2 sc4 = <span class="keyword">new</span> SubClass2(<span class="number">200</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">------SubClass 类继承------</span><br><span class="line">SuperClass()</span><br><span class="line">SubClass</span><br><span class="line">SuperClass(<span class="keyword">int</span> n)</span><br><span class="line">SubClass(<span class="keyword">int</span> n):<span class="number">100</span></span><br><span class="line">------SubClass2 类继承------</span><br><span class="line">SuperClass(<span class="keyword">int</span> n)</span><br><span class="line">SubClass2</span><br><span class="line">SuperClass()</span><br><span class="line">SubClass2(<span class="keyword">int</span> n):<span class="number">200</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数</strong></p>
<p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>
<h2 id="重写-Override-与重载-Overload"><a href="#重写-Override-与重载-Overload" class="headerlink" title="重写(Override)与重载(Overload)"></a>重写(Override)与重载(Overload)</h2><h3 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;动物可以移动&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;狗可以跑和走&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Animal a = <span class="keyword">new</span> Animal(); <span class="comment">// Animal 对象</span></span><br><span class="line">      Animal b = <span class="keyword">new</span> Dog(); <span class="comment">// Dog 对象</span></span><br><span class="line">      a.move();<span class="comment">// 执行 Animal 类的方法</span></span><br><span class="line">      b.move();<span class="comment">//执行 Dog 类的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">狗可以跑和走</span><br></pre></td></tr></table></figure>
<p><strong>方法的重写规则</strong></p>
<ul>
<li><p>参数列表与被重写方法的参数列表必须完全相同。</p>
</li>
<li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p>
</li>
<li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p>
</li>
<li><p>父类的成员方法只能被它的子类重写。</p>
</li>
<li><p>声明为 final 的方法不能被重写。</p>
</li>
<li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p>
</li>
<li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p>
</li>
<li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p>
</li>
<li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p>
</li>
<li><p>构造方法不能被重写。</p>
</li>
<li><p>如果不能继承一个类，则不能重写该类的方法。</p>
<h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h3><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
</li>
</ul>
<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<p>最常用的地方就是构造器的重载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overloading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//以下两个参数类型顺序不同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;returntest3&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String s,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;returntest4&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Overloading o = <span class="keyword">new</span> Overloading();</span><br><span class="line">        System.out.println(o.test());</span><br><span class="line">        o.test(<span class="number">1</span>);</span><br><span class="line">        System.out.println(o.test(<span class="number">1</span>,<span class="string">&quot;test3&quot;</span>));</span><br><span class="line">        System.out.println(o.test(<span class="string">&quot;test4&quot;</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重载规则:</strong></p>
<ul>
<li><p>被重载的方法必须改变参数列表(参数个数或类型不一样)；</p>
</li>
<li><p>被重载的方法可以改变返回类型；</p>
</li>
<li><p>被重载的方法可以改变访问修饰符；</p>
</li>
<li><p>被重载的方法可以声明新的或更广的检查异常；</p>
</li>
<li><p>方法能够在同一个类中或者在一个子类中被重载。</p>
</li>
<li><p>无法以返回值类型作为重载函数的区分标准。</p>
<table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作。</p>
<p>多态性是对象多种表现形式的体现。</p>
<p><strong>多态的优点</strong></p>
<ol>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ol>
<p><strong>多态存在的三个必要条件</strong></p>
<p>继承<br>重写<br>父类引用指向子类对象：<strong>Parent p = new Child();</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Triangle.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>虚函数</strong></p>
<p>虚函数的存在是为了多态。</p>
<p>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p>
<p><strong>多态的实现方式</strong></p>
<p>方式一：重写：</p>
<p>方式二：接口</p>
<p>方式三：抽象类和抽象方法</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>拥有抽象方法的类就是抽象类，抽象类要使用abstract关键字声明.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承抽象类</strong></p>
<p>我们可以通过以下方式继承 Employee 类的属性</p>
<p><strong>抽象类的使用原则</strong><br>（1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；<br>（2）抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；<br>（3）抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；<br>（4）子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wz.abstractdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;<span class="comment">//B类是抽象类的子类，是一个普通类</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="comment">//强制要求覆写</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> B();<span class="comment">//向上转型</span></span><br><span class="line">		</span><br><span class="line">		a.print();<span class="comment">//被子类所覆写的过的方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World !</span><br></pre></td></tr></table></figure>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<p><strong>封装的优点</strong></p>
<ol>
<li>良好的封装能够减少耦合。</li>
<li>类内部的结构可以自由修改。</li>
<li>可以对成员变量进行更精确的控制。</li>
<li>隐藏信息，实现细节。<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2></li>
</ol>
<p>在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p><strong>接口与类相似点</strong></p>
<ol>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ol>
<p><strong>接口与类的区别</strong></p>
<ol>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ol>
<p><strong>接口特性</strong></p>
<ol>
<li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li>
</ol>
<p><strong>抽象类和接口的区别</strong></p>
<ol>
<li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p>
</li>
<li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</p>
</li>
<li><p>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法</p>
</li>
<li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : NameOfInterface.java */</span></span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="comment">//引入包</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NameOfInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">//任何类型 final, static 字段</span></span><br><span class="line">   <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口有以下特性</strong></p>
<ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li>
<li>接口中的方法都是公有的。<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2></li>
</ul>
<p>枚举是一个特殊的类，一般表示一组常量.每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行输出结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Color c1 = Color.RED;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RED</span><br></pre></td></tr></table></figure>

<p><strong>values(), ordinal() 和 valueOf() 方法</strong></p>
<p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p>
<p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p>
<ul>
<li><p>values() 返回枚举类中所有的值。</p>
</li>
<li><p>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</p>
</li>
<li><p>valueOf()方法返回指定字符串值的枚举常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 values()</span></span><br><span class="line">        Color[] arr = Color.values();</span><br><span class="line">        <span class="comment">// 迭代枚举</span></span><br><span class="line">        <span class="keyword">for</span> (Color col : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查看索引</span></span><br><span class="line">            System.out.println(col + <span class="string">&quot; at index &quot;</span> + col.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException</span></span><br><span class="line">        System.out.println(Color.valueOf(<span class="string">&quot;RED&quot;</span>));</span><br><span class="line">        <span class="comment">// System.out.println(Color.valueOf(&quot;WHITE&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RED at index 0</span><br><span class="line">GREEN at index 1</span><br><span class="line">BLUE at index 2</span><br><span class="line">RED</span><br></pre></td></tr></table></figure>

<p><strong>枚举成员</strong></p>
<p>枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor called for : &quot;</span> + <span class="keyword">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">colorInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Universal Color&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h2><p>  为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p>
<p>  <strong>包的 3 个作用如下</strong></p>
<ol>
<li><p>区分相同名称的类。</p>
</li>
<li><p>能够较好地管理大量的类。</p>
</li>
<li><p>控制访问范围。</p>
</li>
</ol>
<p><strong>定义</strong></p>
<pre><code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>Java 包的命名规则如下：</p>
<ul>
<li>包名全部由小写字母（多个单词也全部小写）。</li>
<li>如果包名包含多个层次，每个层次用“.”分割。</li>
<li>包名一般由倒置的域名开头，比如 com.baidu，不要有 www。</li>
<li>自定义包不能 java 开头</li>
</ul>
<p><strong>包导入</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\\如果使用不同包中的其它类，需要使用该类的全名（包名+类名）</span><br><span class="line">    example.Test test = <span class="keyword">new</span> example.Test();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\\<span class="keyword">import</span> 包名+类名;</span><br><span class="line"><span class="keyword">import</span> example.Test;\\or</span><br><span class="line"><span class="keyword">import</span> example.*;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>系统包</strong><br>| 包                    | 说明                                                         |<br>| ——————— | ———————————————————— |<br>| java.lang             | Java 的核心类库，包含运行 Java 程序必不可少的系统类，如基本数据类型、基本数学函数、 字符串处理、异常处理和线程类等，系统默认加载这个包 |<br>| java.io               | Java 语言的标准输入/输出类库，如基本输入/输出流、文件输入/输出、过滤输入/输出流等 |<br>| java.util             | 包含如处理时间的 Date 类，处理动态数组的 Vector 类，以及 Stack 和 HashTable 类 |<br>| java.awt              | 构建图形用户界面（GUI）的类库，低级绘图操作 Graphics 类、图形界面组件和布局管理 （如 Checkbox 类、Container 类、LayoutManger 接口等），以及用户界面交互控制和事 件响应（如 Event 类） |<br>| java.awt.image        | 处理和操纵来自网上的图片的 Java 工具类库                     |<br>| java.wat.peer         | 很少在程序中直接用到，使得同一个 Java 程序在不同的软硬件平台上运行 |<br>| java.net              | 实现网络功能的类库有 Socket 类、ServerSocket 类              |<br>| java.lang.reflect     | 提供用于反射对象的工具                                       |<br>| java.util.zip         | 实现文件压缩功能                                             |<br>| java.awt.datatransfer | 处理数据传输的工具类，包括剪贴板、字符串发送器等             |<br>| java.sql              | 实现 JDBC 的类库                                             |<br>| java.rmi              | 提供远程连接与载入的支持                                     |<br>| java. security        | 提供安全性方面的有关支持                                     |</p>
<h1 id="9-异常处理"><a href="#9-异常处理" class="headerlink" title="9.异常处理"></a>9.异常处理</h1><h2 id="异常处理的概念"><a href="#异常处理的概念" class="headerlink" title="异常处理的概念"></a>异常处理的概念</h2><p>是编程语言或计算机硬件里的一种机制，用于处理软件或信息系统中出现的异常状况（即超出程序正常执行流程的某些特殊条件）。</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>Java异常机制用到的几个关键字：try、catch、finally、throw、throws。</p>
<p><strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常<br>时，异常就被抛出。<br><strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。<br><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络<br>连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语<br>句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。<br><strong>throw</strong> – 用于抛出异常。<br><strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       可能会发生的异常</span><br><span class="line">   &#125;<span class="keyword">catch</span>(异常类型 异常名(变量))&#123;</span><br><span class="line">       针对异常进行处理的代码</span><br><span class="line">   &#125;<span class="keyword">catch</span>(异常类型 异常名(变量))&#123;</span><br><span class="line">       针对异常进行处理的代码</span><br><span class="line">   &#125;...</span><br><span class="line">   [<span class="keyword">finally</span>&#123;</span><br><span class="line">       释放资源代码；</span><br><span class="line">   &#125;]</span><br></pre></td></tr></table></figure>

<h2 id="Error与Exception区别"><a href="#Error与Exception区别" class="headerlink" title="Error与Exception区别"></a>Error与Exception区别</h2><p>Error（错误）是系统中的错误，程序员是不能改变的和处理的，是在程序编译时出现的错误，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。<br>Exception（异常）表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</p>
<h2 id="throw与throws区别"><a href="#throw与throws区别" class="headerlink" title="throw与throws区别"></a>throw与throws区别</h2><p>throw：指的是在方法中人为抛出一个异常对象（这个异常对象可能是自己实例化或者抛出已存在的）；<br><code>throw  ThrowableInstance;</code><br>throws：在方法的声明上使用，表示此方法在调用时必须处理异常。<br><code>throw new NullPointerException(&quot;demo&quot;);</code><br><img src="/images/img/blog/image-20210728140018762.png" alt="image-20210728140018762"></p>
<p>​                                    Java异常层次结构图（网上获取）</p>
<h1 id="10-集合框架"><a href="#10-集合框架" class="headerlink" title="10.集合框架"></a>10.集合框架</h1><p>所有集合类都位于 java.util 包下。Java的集合类主要由两个接口派生而出：Collection 和 Map，Collection 和 Map 是 Java 集合框架的根接口，这两个接口又包含了一些子接口或实现类。</p>
<p>集合框架被设计成要满足以下几个目标：</p>
<ul>
<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。</li>
</ul>
<p>集合框架都包含如下内容：</p>
<ul>
<li><p><strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</p>
</li>
<li><p><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</p>
</li>
<li><p><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</p>
<p><img src="/images/img/blog/image-20210728172402028.png" alt="image-20210728172402028"></p>
</li>
</ul>
<p>Collection是一个基本的集合接口，Collection中可以容纳一组集合元素（Element）</p>
<h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h2><p>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。</p>
<p><strong>List</strong></p>
<p>List接口是一个有序, 元素可重复的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。</p>
<ol>
<li>ArrayList</li>
</ol>
<p>底层数据结构是数组，查改快，增删慢。</p>
<p>非线程安全，效率高</p>
<p>方法：</p>
<p><img src="/images/img/blog/image-20210728173620540.png" alt="image-20210728173620540"></p>
<p>排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;  <span class="comment">// 引入 Collections 类</span></span><br><span class="line">Collections.sort(sites); *<span class="comment">// 字母排序*</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Vector</li>
</ol>
<p>底层数据结构是数组，查改快，增删慢。</p>
<p>线程安全，效率低</p>
<ol start="3">
<li>LinkedList</li>
</ol>
<p>底层数据结构是<strong>链表</strong>，查改慢，增删快。</p>
<p>非线程安全，效率高</p>
<p><strong>以下情况使用 LinkedList :</strong></p>
<ul>
<li>你需要通过循环迭代来访问列表中的某些元素。</li>
<li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li>
</ul>
<p>LinkedList 继承了 AbstractSequentialList 类。</p>
<p>LinkedList 实现了 Queue 接口，可作为队列使用。</p>
<p>LinkedList 实现了 List 接口，可进行列表的相关操作。</p>
<p>LinkedList 实现了 Deque 接口，可作为队列使用。</p>
<p>LinkedList 实现了 Cloneable 接口，可实现克隆。</p>
<p>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p>
<p>方法：</p>
<p><img src="/images/img/blog/image-20210728174512617.png" alt="image-20210728174512617"></p>
<p><strong>Set</strong></p>
<p>Set 接口存储一组唯一，无序的对象。</p>
<ol>
<li>HashSet</li>
</ol>
<p>底层数据结构是哈希表。(无序**,唯一**)</p>
<p>依赖两个方法：hashCode()和equals() 保证元素唯一性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 HashSet 类      </span></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;String&gt; sites = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);  <span class="comment">// 重复的元素不会被添加</span></span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码只会输出一个Runoob。</p>
<ol start="2">
<li>LinkedHashSet</li>
</ol>
<p>底层数据结构是链表和哈希表。(FIFO插入有序,唯一)</p>
<p>1.由链表保证元素有序</p>
<p>2.由哈希表保证元素唯一</p>
<ol start="3">
<li>TreeSet</li>
</ol>
<p>底层数据结构是红黑树。(唯一，有序)</p>
<p>如何保证元素排序的呢? 自然排序，比较器排序</p>
<h2 id="Set和List的区别"><a href="#Set和List的区别" class="headerlink" title="Set和List的区别"></a>Set和List的区别</h2><ul>
<li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</li>
<li>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **&lt;实现类有HashSet,TreeSet&gt;**。</li>
<li>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <strong>&lt;实现类有ArrayList,LinkedList,Vector&gt;</strong> 。</li>
</ul>
<p><img src="/images/img/blog/image-20210728172343233.png" alt="image-20210728172343233"></p>
<p>Map与Collection是并列关系。Map提供键（key）到值（value）的映射。一个Map中不能包含相同的键，每个键只能映射一个值。</p>
<ol>
<li>HashMap</li>
</ol>
<p>无序，非线程安全，效率高。HashMap允许null值（key和value都允许）。</p>
<p><img src="/images/img/blog/image-20210728174945196.png" alt="image-20210728174945196"></p>
<ol start="2">
<li>HashTable</li>
</ol>
<p>无序，线程安全，效率低。除构造函数外，HashTable的所有 public 方法声明中都有 synchronized关键字，而HashMap的源码中则没有。HashTable不允许null值（key和value都允许）。</p>
<ol start="3">
<li>TreeMap</li>
</ol>
<p>有序，非线程安全，效率高（O(logN)），但比不上HashMap (O(1))。</p>
<h1 id="11-流-Stream-、文件-File-和IO"><a href="#11-流-Stream-、文件-File-和IO" class="headerlink" title="11.流(Stream)、文件(File)和IO"></a>11.流(Stream)、文件(File)和IO</h1><p>Java.io 包中定义了多个流类型（类或抽象类）来实现输入/输出功能；</p>
<p><img src="/images/img/blog/1320926-20200115201550919-765865084.png" alt="img"></p>
<p>可以从不同的角度对其进行分<br>类：<br>1.按数据流的方向不同可以分为输入流【InputStream（字节流），Reader（字符流）】和输出流【OutPutStream（字节流），Writer（字符流）】<br>2.按照处理数据单位不同可以分为字节流【一个字节（Byte）是8位（bit）)】和字符流【一个字符是2个字节】<br>3.按照功能不同可以分为节点流和处理流</p>
<p><img src="/images/img/blog/image-20210905011146261.png" alt="image-20210905011146261"></p>
<p>4.按照操作对象分</p>
<p><img src="/images/img/blog/1320926-20200115201810097-1009499186.png" alt="img"></p>
<h2 id="InputStream-和-OutputStream"><a href="#InputStream-和-OutputStream" class="headerlink" title="InputStream 和 OutputStream"></a>InputStream 和 OutputStream</h2><p><img src="/images/img/blog/2012121818562293.png" alt="img"></p>
<p><img src="/images/img/blog/2012121819001442.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span> bWrite[] = &#123; <span class="number">11</span>, <span class="number">21</span>, <span class="number">3</span>, <span class="number">40</span>, <span class="number">5</span> &#125;;</span><br><span class="line">            OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; bWrite.length; x++) &#123;</span><br><span class="line">                os.write(bWrite[x]); <span class="comment">// writes the bytes</span></span><br><span class="line">            &#125;</span><br><span class="line">            os.close();</span><br><span class="line"> </span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> size = is.available();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) is.read() + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。</p>
<p>以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名 :fileStreamTest2.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileStreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fop = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">        <span class="comment">// 构建FileOutputStream对象,文件不存在会自动新建</span></span><br><span class="line">        OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fop, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk</span></span><br><span class="line">        writer.append(<span class="string">&quot;中文输入&quot;</span>);</span><br><span class="line">        <span class="comment">// 写入到缓冲区</span></span><br><span class="line">        writer.append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 换行</span></span><br><span class="line">        writer.append(<span class="string">&quot;English&quot;</span>);</span><br><span class="line">        <span class="comment">// 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入</span></span><br><span class="line">        writer.close();</span><br><span class="line">        <span class="comment">// 关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉</span></span><br><span class="line">        fop.close();</span><br><span class="line">        <span class="comment">// 关闭输出流,释放系统资源</span></span><br><span class="line">        FileInputStream fip = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        <span class="comment">// 构建FileInputStream对象</span></span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fip, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 构建InputStreamReader对象,编码与写入相同</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (reader.ready()) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) reader.read());</span><br><span class="line">            <span class="comment">// 转成char加到StringBuffer对象中</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">// 关闭读取流</span></span><br><span class="line">        fip.close();</span><br><span class="line">        <span class="comment">// 关闭输入流,释放系统资源</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reader-流与Writer流"><a href="#Reader-流与Writer流" class="headerlink" title="Reader 流与Writer流"></a>Reader 流与Writer流</h2><p><img src="/images/img/blog/2012121819033620.png" alt="img"></p>
<p><img src="/images/img/blog/2012121819042121.png" alt="img"></p>
<p>Reader ,Write与InputStream ，OutputStream： 唯一的区别就在于读的数据单位不同分别为（16bit），（8bit）</p>
<h2 id="创建读取目录："><a href="#创建读取目录：" class="headerlink" title="创建读取目录："></a>创建读取目录：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateDir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String dirname = <span class="string">&quot;/tmp/user/java/bin&quot;</span>;</span><br><span class="line">        File d = <span class="keyword">new</span> File(dirname);</span><br><span class="line">        <span class="comment">// 现在创建目录</span></span><br><span class="line">        d.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String dirname = <span class="string">&quot;/tmp&quot;</span>;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(dirname);</span><br><span class="line">        <span class="keyword">if</span> (f1.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目录 &quot;</span> + dirname);</span><br><span class="line">            String s[] = f1.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File(dirname + <span class="string">&quot;/&quot;</span> + s[i]);</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; 是一个目录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; 是一个文件&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(dirname + <span class="string">&quot; 不是一个目录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteFileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里修改为自己的测试目录</span></span><br><span class="line">        File folder = <span class="keyword">new</span> File(<span class="string">&quot;/tmp/java/&quot;</span>);</span><br><span class="line">        deleteFolder(folder);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除文件及目录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFolder</span><span class="params">(File folder)</span> </span>&#123;</span><br><span class="line">        File[] files = folder.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                    deleteFolder(f);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        folder.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h2><p>是处理流的一种，它是要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，避免频繁读写硬盘， 提高了读写的效率。同时增加了一些新的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader(Reader in)</span><br><span class="line">BufferedReader(Reader in,<span class="keyword">int</span> sz) <span class="comment">//sz 为自定义缓冲区的大小</span></span><br><span class="line">BufferedWriter(Writer out)</span><br><span class="line">BufferedWriter(Writer out,<span class="keyword">int</span> sz)</span><br><span class="line">BufferedInputStream(InputStream in)</span><br><span class="line">BufferedInputStream(InputStream in,<span class="keyword">int</span> size)</span><br><span class="line">BufferedOutputStream(InputStream in)</span><br><span class="line">BufferedOutputStream(InputStream in,<span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure>
<p>BufferedInputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.chapter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream( f);</span><br><span class="line"><span class="comment">// 在FileInputStream节点流的外面套接一层处理流BufferedInputStream</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">System.out.println((<span class="keyword">char</span>) bis.read());</span><br><span class="line">System.out.println((<span class="keyword">char</span>) bis.read());</span><br><span class="line">bis.mark(<span class="number">100</span>);<span class="comment">// 在第100个字符处做一个标记</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; (c = bis.read()) != -<span class="number">1</span>; i++) &#123;</span><br><span class="line">System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">bis.reset();<span class="comment">// 重新回到原来标记的地方</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; (c = bis.read()) != -<span class="number">1</span>; i++) &#123;</span><br><span class="line">System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">&#125;</span><br><span class="line">bis.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BufferedReader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.chapter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;a\\Student.txt&quot;</span>));</span><br><span class="line"><span class="comment">//在节点流FileWriter的外面再套一层处理流BufferedWriter</span></span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">s = String.valueOf(Math.random());<span class="comment">//“Math.random()”将会生成一系列介于0～1之间的随机数。</span></span><br><span class="line"><span class="comment">// static String valueOf(double d)这个valueOf()方法的作用就是把</span></span><br><span class="line">一个<span class="keyword">double</span>类型的数转换成字符串</span><br><span class="line"><span class="comment">//valueOf()是一个静态方法，所以可以使用“类型.静态方法名”的形式来调用</span></span><br><span class="line">bw.write(s);<span class="comment">//把随机数字符串写入到指定文件中</span></span><br><span class="line">bw.newLine();<span class="comment">//调用newLine()方法使得每写入一个随机数就换行显示</span></span><br><span class="line">&#125;</span><br><span class="line">bw.flush();<span class="comment">//调用flush()方法清空缓冲区</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a:\\Student.txt&quot;</span>));</span><br><span class="line"><span class="comment">//在节点流FileReader的外面再套一层处理流BufferedReader</span></span><br><span class="line"><span class="keyword">while</span>((s = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//使用BufferedReader处理流里面提供String readLine()方法读取文件中的数据时是一行一行读取的</span></span><br><span class="line"><span class="comment">//循环结束的条件就是使用readLine()方法读取数据返回的字符串为空值后则表</span></span><br><span class="line">示已经读取到文件的末尾了。</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">bw.close();</span><br><span class="line">br.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p><strong>InputStreamReader 和 OutputStreamWriter 用于字节数据到字符数据之间的转换</strong><br>InputStreamReader 需要和 InputStream “套接” 。<br>OutputStreamWriter 需要和 OutputStream “套接” 。<br>转换流在构造时可以指定其编码集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransform1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:/char.txt&quot;</span>));</span><br><span class="line">    osw.write(<span class="string">&quot;熊方园真烦人&quot;</span>);<span class="comment">// 把字符串写入到指定的文件中去</span></span><br><span class="line">    System.out.println(osw.getEncoding());<span class="comment">// 使用getEncoding()方法取得当前系统的默认字符编码</span></span><br><span class="line">    osw.close();</span><br><span class="line">    osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\java\\char.txt&quot;</span>, <span class="keyword">true</span>), <span class="string">&quot;utf-8&quot;</span>);<span class="comment">// 如果在调用FileOutputStream的构造方法时没有加入true，那么新加入的字符    串就会替换掉原来写入的字符串，在调用构造方法时指定了字符的编码</span></span><br><span class="line">    osw.write(<span class="string">&quot;不想搭理她&quot;</span>);<span class="comment">// 再次向指定的文件写入字符串，新写入的字符串加入到原来字符串的后面</span></span><br><span class="line">    System.out.println(osw.getEncoding());</span><br><span class="line">    osw.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>数据流 DataInputStream DataOutputStream 【分别继承自InputStream 和 OutputStream】等-提供将基础数据类型写入到文件中，或者读取出来.提供了可以存取与机器无关的Java原始类型数据（int，double等）的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="comment">//在调用构造方法时，首先会在内存里面创建一个ByteArray字节数组</span></span><br><span class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);</span><br><span class="line"><span class="comment">//在输出流的外面套上一层数据流，用来处理int，double类型的数</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    dos.writeDouble(Math.random());<span class="comment">//把产生的随机数直接写入到字节数组</span></span><br><span class="line">    ByteArray中</span><br><span class="line">    dos.writeBoolean(<span class="keyword">true</span>);<span class="comment">//布尔类型的数据在内存中就只占一个字节</span></span><br><span class="line">    ByteArrayInputStream bais = <span class="keyword">new</span></span><br><span class="line">    ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        System.out.println(bais.available());</span><br><span class="line">    DataInputStream dis = <span class="keyword">new</span> DataInputStream(bais);</span><br><span class="line">    System.out.println(dis.readDouble());<span class="comment">//先写进去的就先读出来，调用readDouble()方法读取出写入的随机数</span></span><br><span class="line">    System.out.println(dis.readBoolean());<span class="comment">//后写进去的就后读出来，这里面的读取顺序不能更改位置，否则会打印出不正确的结果</span></span><br><span class="line">    dos.close();</span><br><span class="line">    bais.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>打印流是输出信息最方便的类，注意包含字节打印流PrintStream和字符打印流：PrintWriter。打印流提供了非常方便的打印功能，<br>可以打印任何类型的数据信息，例如：小数，整数，字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>对象的输入输出流的作用： 用于写入对象 的信息和读取对象的信息。 使得对象持久化。<br>  ObjectInputStream  : 对象输入流<br>  ObjectOutPutStream ：对象输出流 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建要写入磁盘的类，这个类需要实现接口 Serializable（可系列化的）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在这里保证了serialVersionUID 的唯一性，防止属性变量的临时改变，从而造成写入id与读取id不同</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">int</span> id ; <span class="comment">//额外需要添加一个属性</span></span><br><span class="line">    String name ;</span><br><span class="line">    <span class="keyword">transient</span> String sex; <span class="comment">//transient修饰属性，表示暂时的，则这个属性不会被写入磁盘</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,String sex,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">objectIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        createObj();</span><br><span class="line">        readObj();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（一）先写入对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建目标路径</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\bg\\Desktop\\objTest.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建流通道</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        <span class="comment">//3.创建对象输出流</span></span><br><span class="line">        ObjectOutputStream objOP = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        <span class="comment">//4.创建类对象，并初始化</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;玛丽苏&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//5.向目标路径文件写入对象</span></span><br><span class="line">        objOP.writeObject(stu);</span><br><span class="line">        <span class="comment">//6.关闭资源</span></span><br><span class="line">        objOP.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再读取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\bg\\Desktop\\objTest.txt&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        ObjectInputStream objIP = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        <span class="comment">//读取对象数据，需要将对象流强制转换为 要写入对象的类型</span></span><br><span class="line">        Student stu = (Student)objIP.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n name:&quot;</span>+stu.name+<span class="string">&quot;\n sex:&quot;</span>+stu.sex+<span class="string">&quot;\n age:&quot;</span>+stu.age);</span><br><span class="line">        objIP.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流的关闭顺序"><a href="#流的关闭顺序" class="headerlink" title="流的关闭顺序"></a>流的关闭顺序</h2><ol>
<li>一般情况下是：先打开的后关闭，后打开的先关闭</li>
<li>另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b</li>
<li>可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。<h1 id="12-多线程"><a href="#12-多线程" class="headerlink" title="12.多线程"></a>12.多线程</h1></li>
</ol>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>继承Thread类，实现Runnable接口，实现Callable接口</p>
<p><strong>1.继承Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCreateDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start(); <span class="comment">//调用start()方法启动线程,线程不一定立即执行，CPU安排调度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//重写run()方法，编写线程执行体</span></span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;hellow_world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现Runnable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCreateDemo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建线程对象，调用start()方法启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过Runnable创建的线程!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两种创建方式,工作时性质一样。但是建议使用***实现Runable接口***方式。解决单继承的局限性。</p>
<p><strong>3.实现Callable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCreateDemo3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 实现call方法，作为线程执行体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// call()方法可以有返回值</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Callable对象</span></span><br><span class="line">        ThreadCreateDemo3 myCallableTest = <span class="keyword">new</span> ThreadCreateDemo3();</span><br><span class="line">        <span class="comment">// 使用FutureTask来包装Callable对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(myCallableTest);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; \t&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>)&#123;</span><br><span class="line">                <span class="comment">// 实质还是以Callable对象来创建、并启动线程</span></span><br><span class="line">                <span class="keyword">new</span> Thread(task , <span class="string">&quot;callable&quot;</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 获取线程返回值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;callable返回值：&quot;</span> + task.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>实现Callable接口，需要返回值类型</p>
</li>
<li><p>重写call方法，需要抛出异常</p>
</li>
<li><p>创建目标对象</p>
</li>
<li><p>创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);</p>
</li>
<li><p>提交执行：Future<Boolean> result1 = ser.submit(t1);</p>
</li>
<li><p>获取结果：boolean r1 = result1.get()</p>
</li>
<li><p>关闭服务：ser.shutdownNow();<br><strong>总结</strong></p>
</li>
<li><p>不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。 因此可以将实现Runnable接口和实现Callable接口归为一种方式。</p>
</li>
<li><p>Runnable、Callable接口的方式创建多线程,所以非常适合多个相同线程来处理同一份资源的情况,如果需要访问当前线程，则必须使用Thread.currentThread()方法</p>
</li>
<li><p>采用继承Thread类的方式创建多线程,因为线程类已经继承了Thread类，所以不能再继承其他父类</p>
</li>
</ol>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态</p>
<p><img src="/images/img/blog/%E4%B8%8B%E8%BD%BD.png" alt="下载"></p>
<p><img src="/images/img/blog/image-20210809153146504.png" alt="image-20210809153146504"><br>Thread.State：</p>
<ol>
<li><p>**初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。</p>
</li>
<li><p>**运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</p>
</li>
<li><p>**阻塞(BLOCKED)**：表示线程阻塞于锁。</p>
</li>
<li><p>**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
</li>
<li><p>**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。</p>
</li>
<li><p>**终止(TERMINATED)**：表示该线程已经执行完毕</p>
</li>
</ol>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p> Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度<br>器按照优先级决定应该调度哪个线程来执行。<br>线程的优先级用数字表示，范围从1~10.<br>hread.MIN_PRIORITY = 1;<br>Thread.MAX_PRIORITY = 10;<br>Thread.NORM_PRIORITY = 5;<br>使用以下方式改变或获取优先级<br>getPriority() . setPriority(int xxx)</p>
<h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><table>
<thead>
<tr>
<th>1</th>
<th><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td>
</tr>
<tr>
<td>5</td>
<td><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td>6</td>
<td><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td>7</td>
<td><strong>public void interrupt()</strong> 中断线程。</td>
</tr>
<tr>
<td>8</td>
<td><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td>
</tr>
<tr>
<td>9</td>
<td><strong>public static void yield()</strong> 线程礼让： 暂停当前正在执行的线程对象，并执行其他线程。</td>
</tr>
<tr>
<td>10</td>
<td><strong>public static void sleep(long millisec)</strong> 线程休眠： 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
<tr>
<td>11</td>
<td><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td>
</tr>
<tr>
<td>12</td>
<td><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td>13</td>
<td><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td>
</tr>
</tbody></table>
<p>停止线程：jdk提供了stop，但不建议使用可以自己去停止它</p>
<h2 id="守护-daemon-线程"><a href="#守护-daemon-线程" class="headerlink" title="守护(daemon)线程"></a>守护(daemon)线程</h2><p>线程分为前台线程与后台线程（用户线程与守护线程）<br>虚拟机必须确保用户线程执行完毕<br>虚拟机不用等待守护线程执行完毕</p>
<h2 id="并发，队列-和-锁，死锁"><a href="#并发，队列-和-锁，死锁" class="headerlink" title="并发，队列 和 锁，死锁"></a>并发，队列 和 锁，死锁</h2><p>同一个对象被多个线程同时操作就是并发。</p>
<p>多个线程访问同一个对象, 并且某些线程还想修改这个对象 .这时候我们就需要线程同步 . 线程同步其实就是一种等待机制 , 多个需要同时访问此对象的线程进入这个对象的等待池 形成队列, 等待前面线程使用完毕 , 下一个线<br>程再使用。</p>
<p>上面的并发问题我们会加一个锁（synchronized）来解决。我锁上门的时候你们都别进来。但是加上锁之后会有以下为：</p>
<ol>
<li><p>一个线程持有锁会导致其他所有需要此锁的线程挂起 ;</p>
</li>
<li><p>在多线程竞争下 , 加锁 , 释放锁会导致比较多的上下文切换 和 调度延时,引起性能问题 ;</p>
</li>
<li><p>如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒置 , 引起性能问题 .</p>
<p>java 死锁产生的四个必要条件：</p>
</li>
</ol>
<ul>
<li><p>1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用</p>
</li>
<li><p>2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</p>
</li>
<li><p>3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</p>
</li>
<li><p>4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。</p>
<p>死锁的情况下如果打破上述任何一个条件，便可让死锁消失。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String obj1 = <span class="string">&quot;obj1&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String obj2 = <span class="string">&quot;obj2&quot;</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      LockA la = <span class="keyword">new</span> LockA();</span><br><span class="line">      <span class="keyword">new</span> Thread(la).start();</span><br><span class="line">      LockB lb = <span class="keyword">new</span> LockB();</span><br><span class="line">      <span class="keyword">new</span> Thread(lb).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockA</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockA 开始执行&quot;</span>);</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockTest.obj1) &#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockA 锁住 obj1&quot;</span>);</span><br><span class="line">               Thread.sleep(<span class="number">3000</span>); <span class="comment">// 此处等待是给B能锁住机会</span></span><br><span class="line">               <span class="keyword">synchronized</span> (LockTest.obj2) &#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockA 锁住 obj2&quot;</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 为测试，占用了就不放</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockB</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockB 开始执行&quot;</span>);</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockTest.obj2) &#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockB 锁住 obj2&quot;</span>);</span><br><span class="line">               Thread.sleep(<span class="number">3000</span>); <span class="comment">// 此处等待是给A能锁住机会</span></span><br><span class="line">               <span class="keyword">synchronized</span> (LockTest.obj1) &#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockB 锁住 obj1&quot;</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 为测试，占用了就不放</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">06</span> CST <span class="number">2015</span> LockB 开始执行</span><br><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">06</span> CST <span class="number">2015</span> LockA 开始执行</span><br><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">06</span> CST <span class="number">2015</span> LockB 锁住 obj2</span><br><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">06</span> CST <span class="number">2015</span> LockA 锁住 obj1</span><br></pre></td></tr></table></figure>

<p>解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnLockTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String obj1 = <span class="string">&quot;obj1&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore a1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String obj2 = <span class="string">&quot;obj2&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore a2 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      LockAa la = <span class="keyword">new</span> LockAa();</span><br><span class="line">      <span class="keyword">new</span> Thread(la).start();</span><br><span class="line">      LockBb lb = <span class="keyword">new</span> LockBb();</span><br><span class="line">      <span class="keyword">new</span> Thread(lb).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockAa</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockA 开始执行&quot;</span>);</span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UnLockTest.a1.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockA 锁住 obj1&quot;</span>);</span><br><span class="line">               <span class="keyword">if</span> (UnLockTest.a2.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockA 锁住 obj2&quot;</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// do something</span></span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot;LockA 锁 obj2 失败&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot;LockA 锁 obj1 失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            UnLockTest.a1.release(); <span class="comment">// 释放</span></span><br><span class="line">            UnLockTest.a2.release();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 马上进行尝试，现实情况下do something是不确定的</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockBb</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockB 开始执行&quot;</span>);</span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UnLockTest.a2.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockB 锁住 obj2&quot;</span>);</span><br><span class="line">               <span class="keyword">if</span> (UnLockTest.a1.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot; LockB 锁住 obj1&quot;</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// do something</span></span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot;LockB 锁 obj1 失败&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> Date().toString() + <span class="string">&quot;LockB 锁 obj2 失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            UnLockTest.a1.release(); <span class="comment">// 释放</span></span><br><span class="line">            UnLockTest.a2.release();</span><br><span class="line">            Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">// 这里只是为了演示，所以tryAcquire只用1秒，而且B要给A让出能执行的时间，否则两个永远是死锁</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">13</span> CST <span class="number">2015</span> LockA 开始执行</span><br><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">13</span> CST <span class="number">2015</span> LockB 开始执行</span><br><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">13</span> CST <span class="number">2015</span> LockB 锁住 obj2</span><br><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">13</span> CST <span class="number">2015</span> LockA 锁住 obj1</span><br><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">14</span> CST 2015LockB 锁 obj1 失败</span><br><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">14</span> CST 2015LockA 锁 obj2 失败</span><br><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">15</span> CST <span class="number">2015</span> LockA 锁住 obj1</span><br><span class="line">Tue May <span class="number">05</span> <span class="number">10</span>:<span class="number">59</span>:<span class="number">15</span> CST <span class="number">2015</span> LockA 锁住 obj2</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>synchronized 与 Lock 的对比</strong><br>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
<li>优先使用顺序：<br>Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt; 同步方法（在方<br>法体之外）</li>
</ol>
<h2 id="线程通讯"><a href="#线程通讯" class="headerlink" title="线程通讯"></a>线程通讯</h2><p>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p>
<p><strong>线程的通信方式</strong></p>
<ol>
<li>volatile</li>
<li>Wait/Notify机制</li>
<li>join方式</li>
<li>threadLocal</li>
<li>CountDownLatch 并发工具</li>
<li>CyclicBarrier 并发工具</li>
</ol>
<p><strong>volatile</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Boolean flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - 执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Volatile());</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">5</span>);</span><br><span class="line">      flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> - 执行</span><br><span class="line">Thread-<span class="number">0</span> - 执行</span><br><span class="line">Thread-<span class="number">0</span> - 执行</span><br><span class="line">Thread-<span class="number">0</span> - 执行</span><br><span class="line">Thread-<span class="number">0</span> - 执行</span><br><span class="line">线程结束</span><br></pre></td></tr></table></figure>
<p>**WaitNotify **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态锁</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Integer i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + i);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          i++;</span><br><span class="line">          lock.notify();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + i);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          i++;</span><br><span class="line">          lock.notify();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    WaitNotify waitNotify = <span class="keyword">new</span> WaitNotify();</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; waitNotify.odd(), <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; waitNotify.even(), <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>join</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadCommunication;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> sleepTime = (<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>);</span><br><span class="line">            System.out.println(sleepTime);</span><br><span class="line">            Thread.sleep(sleepTime);</span><br><span class="line">            System.out.println(<span class="string">&quot;JoinTest end&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        JoinTest j = <span class="keyword">new</span> JoinTest();</span><br><span class="line">        j.start();</span><br><span class="line">        j.join();<span class="comment">//当前线程main等待线程对象（j)销毁</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>threadLocal</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sync; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceNumber</span> </span>&#123; </span><br><span class="line"> <span class="comment">// 定义匿名子类创建ThreadLocal的变量 </span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqNum = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123; </span><br><span class="line"> <span class="comment">// 覆盖初始化方法 </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> 	&#125; </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="comment">// 下一个序列号 </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNum</span><span class="params">()</span> </span>&#123; </span><br><span class="line">     seqNum.set(seqNum.get() + <span class="number">1</span>); </span><br><span class="line">     <span class="keyword">return</span> seqNum.get(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">     <span class="keyword">private</span> SequenceNumber sn; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">TestClient</span><span class="params">(SequenceNumber sn)</span> </span>&#123; </span><br><span class="line">     <span class="keyword">this</span>.sn = sn; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 线程产生序列号 </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; </span><br><span class="line">         System.out.println(<span class="string">&quot;thread[&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] sn[&quot;</span> + 			sn.getNextNum() + <span class="string">&quot;]&quot;</span>); </span><br><span class="line">         &#125; </span><br><span class="line"> 	&#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     SequenceNumber sn = <span class="keyword">new</span> SequenceNumber(); </span><br><span class="line">     <span class="comment">// 三个线程产生各自的序列号 </span></span><br><span class="line">     TestClient t1 = <span class="keyword">new</span> TestClient(sn); </span><br><span class="line">     TestClient t2 = <span class="keyword">new</span> TestClient(sn); </span><br><span class="line">     TestClient t3 = <span class="keyword">new</span> TestClient(sn); </span><br><span class="line">     t1.start(); </span><br><span class="line">     t2.start(); </span><br><span class="line">     t3.start(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread[Thread-1] sn[1] </span><br><span class="line">thread[Thread-1] sn[2] </span><br><span class="line">thread[Thread-1] sn[3] </span><br><span class="line">thread[Thread-2] sn[1] </span><br><span class="line">thread[Thread-2] sn[2] </span><br><span class="line">thread[Thread-2] sn[3] </span><br><span class="line">thread[Thread-0] sn[1]</span><br><span class="line">thread[Thread-0] sn[2] </span><br><span class="line">thread[Thread-0] sn[3]</span><br></pre></td></tr></table></figure>

<p>**CountDownLatch **CountDownLatch<code>可以代替</code>wait/notify<code>的使用,并去掉</code>synchronized</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDown &#123;</span><br><span class="line">  private static Integer i &#x3D; 0;</span><br><span class="line">  final static CountDownLatch countDown &#x3D; new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">  public void odd() &#123;</span><br><span class="line">    while (i &lt; 10) &#123;</span><br><span class="line">      if (i % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; - &quot; + i);</span><br><span class="line">        try &#123;</span><br><span class="line">          Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        countDown.countDown();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          countDown.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void even() &#123;</span><br><span class="line">    while (i &lt; 10) &#123;</span><br><span class="line">      if (i % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; - &quot; + i);</span><br><span class="line">        try &#123;</span><br><span class="line">          Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        countDown.countDown();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          countDown.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    CountDown countDown &#x3D; new CountDown();</span><br><span class="line"></span><br><span class="line">    Thread t1 &#x3D; new Thread(() -&gt; countDown.odd(), &quot;线程1&quot;);</span><br><span class="line">    Thread t2 &#x3D; new Thread(() -&gt; countDown.even(), &quot;线程2&quot;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>CyclicBarrier</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 准备...&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;全部启动完毕!&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 准备...&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;全部启动完毕!&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 准备...&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;全部启动完毕!&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;线程3&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程3: 准备...</span><br><span class="line">线程2: 准备...</span><br><span class="line">线程1: 准备...</span><br><span class="line">全部启动完毕!</span><br><span class="line">全部启动完毕!</span><br><span class="line">全部启动完毕!</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</p>
<p>ExecutorService 和 Executors</p>
<ol>
<li><p><strong>ExecutorService：</strong>真正的线程池接口。常见子类ThreadPoolExecutor<br>void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执<br>行Runnable</p>
</li>
<li><p><T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般又来执行<br>Callable</p>
</li>
<li><p>void shutdown() ：关闭连接池</p>
</li>
</ol>
<p> <strong>Executors：</strong>工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p>
<h1 id="13-注解"><a href="#13-注解" class="headerlink" title="13.注解"></a>13.注解</h1><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p>
<p><strong>作用</strong></p>
<p>不是程序本身 , 可以对程序作出解释.(这一点和注释(comment)没什么区别)</p>
<p>可以被其他程序(比如:编译器等)读取.</p>
<p>可以附加在package , class , method , field 等上面 , 相当于给他们添加了额外的辅助信息</p>
<p>我们可以通过反射机制实现对这些元数据的访问</p>
<p><strong>格式</strong></p>
<p>注解是以”@注释名”在代码中存在的</p>
<p>还可以添加一些参数值 , 例如:@SuppressWarnings(value=”unchecked”)</p>
<h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><p><img src="/images/img/blog/image-20210809164852100.png" alt="image-20210809164852100"><br>Java 定义了一套注解，共有 10 个，java7之前3 个在 java.lang 中， 4 个在 java.lang.annotation 中，后续增加三个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">作用在代码的注解( java.lang )是</span><br><span class="line"><span class="meta">@Override</span> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</span><br><span class="line"><span class="meta">@Deprecated</span> - 标记过时方法。如果使用该方法，会报编译警告。</span><br><span class="line"><span class="meta">@SuppressWarnings</span> - 指示编译器去忽略注解中声明的警告。</span><br><span class="line">作用在其他注解的注解(或者说 元注解)是( java.lang.annotation)注解</span><br><span class="line"><span class="meta">@Retention</span> - 标识这个注解怎么保存，是只在代码中，还是编入<span class="class"><span class="keyword">class</span>文件中，或者是在运行时可以通过反射访问。</span></span><br><span class="line"><span class="class">@<span class="title">Documented</span> - 标记这些注解是否包含在用户文档中。</span></span><br><span class="line"><span class="class">@<span class="title">Target</span> - 标记这个注解应该是哪种 <span class="title">Java</span> 成员。</span></span><br><span class="line"><span class="class">@<span class="title">Inherited</span> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</span></span><br><span class="line"><span class="class"><span class="title">java7</span>之后增加的注解</span></span><br><span class="line"><span class="class">@<span class="title">SafeVarargs</span> - <span class="title">Java</span> 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</span></span><br><span class="line"><span class="class">@<span class="title">FunctionalInterface</span> - <span class="title">Java</span> 8 开始支持，标识一个匿名函数或函数式接口。</span></span><br><span class="line"><span class="class">@<span class="title">Repeatable</span> - <span class="title">Java</span> 8 开始支持，标识某注解可以在同一个声明上使用多次。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.annotation;</span><br><span class="line"><span class="comment">//测试内置注解</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//所有类默认继承Object类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@Override 表示方法重写</span></span><br><span class="line">    <span class="comment">//--&gt; 查看JDK帮助文档</span></span><br><span class="line">    <span class="comment">//--&gt; 测试名字不同产生的效果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//方法过时了, 不建议使用 , 可能存在问题 , 并不是不能使用!</span></span><br><span class="line">    <span class="comment">//--&gt; 查看JDK帮助文档</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;测试 @Deprecated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@SuppressWarnings 抑制警告 , 可以传参数</span></span><br><span class="line">    <span class="comment">//--&gt; 查看JDK帮助文档</span></span><br><span class="line">    <span class="comment">//查看源码:发现 参数类型 和 参数名称 , 并不是方法!</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sw</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	 List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p><strong>元注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="comment">//测试元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="meta">@MyAnnotation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个注解</span></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ol>
<li><p>使用 @interface自定义注解时 , 自动继承了java.lang.annotation.Annotation接口<br>@ interface用来声明一个注解 , 格式 : public @ interface 注解名 { 定义内容 }</p>
</li>
<li><p>其中的每一个方法实际上是声明了一个配置参数.<br>方法的名称就是参数的名称.</p>
</li>
<li><p>返回值类型就是参数的类型 ( 返回值只能是基本类型,Class , String , enum ).<br>可以通过default来声明参数的默认值</p>
</li>
<li><p>如果只有一个参数成员 , 一般参数名为value</p>
</li>
<li><p>注解元素必须要有值 , 我们定义注解元素时 , 经常使用空字符串,0作为默认值 .</p>
</li>
</ol>
<p><strong>注解参数的可支持数据类型：</strong><br>1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)<br>2.String类型<br>3.Class类型<br>4.enum类型<br>5.Annotation类型<br>6.以上所有类型的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果名称注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peida</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitName &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果颜色注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peida</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitColor &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色枚举</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> peida</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span>&#123; BULE,RED,GREEN&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Color <span class="title">fruitColor</span><span class="params">()</span> <span class="keyword">default</span> Color.GREEN</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> annotation.FruitColor.Color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@FruitName(&quot;Apple&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appleName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@FruitColor(fruitColor=Color.RED)</span></span><br><span class="line">    <span class="keyword">private</span> String appleColor;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppleColor</span><span class="params">(String appleColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.appleColor = appleColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppleColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appleColor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppleName</span><span class="params">(String appleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.appleName = appleName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appleName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;水果的名字是：苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置默认值</span></span><br><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果供应者注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> peida</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitProvider &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">address</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-反射"><a href="#14-反射" class="headerlink" title="14.反射"></a>14.反射</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p><img src="/images/img/blog/image-20210809170425919.png" alt="image-20210809170425919"></p>
<p>Java的反射机制的实现要借助于4个类：class，Constructor，Field，Method;<br>其中class代表的时类对 象，Constructor－类的构造器对象，Field－类的属性对象，Method－类的方法对象。通过这四个对象我们可以粗略的看到一个类的各个组 成部分。</p>
<p><strong>获取类的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用运行时类本身的.class属性</span></span><br><span class="line">Class clazz = String.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过运行时类的对象获取</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">Class clazz = p.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Class的静态方法获取:体现反射的动态性</span></span><br><span class="line">String className = “java.util.commons”;</span><br><span class="line"></span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类的加载器</span></span><br><span class="line">String className = “java.util.commons”;</span><br><span class="line"></span><br><span class="line">ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line">Class clazz = classLoader.loadClass(className);</span><br></pre></td></tr></table></figure>

<p><strong>得到构造器的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Constructor <span class="title">getConstructor</span><span class="params">(Class[] params)</span> -- 获得使用特殊的参数类型的公共构造函数， </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getConstructors</span><span class="params">()</span> -- 获得类的所有公共构造函数 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class[] params)</span> -- 获得使用特定参数类型的构造函数<span class="params">(与接入级别无关)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getDeclaredConstructors</span><span class="params">()</span> -- 获得类的所有构造函数<span class="params">(与接入级别无关)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>获取字段</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span> -- 获得命名的公共字段 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span> -- 获得类的所有公共字段 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> -- 获得类声明的命名的字段 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span> -- 获得类声明的所有字段</span></span><br></pre></td></tr></table></figure>
<p><strong>获取方法的信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class[] params)</span> -- 使用特定的参数类型，获得命名的公共方法 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> -- 获得类的所有公共方法 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class[] params)</span> -- 使用特写的参数类型，获得类声明的命名的方法 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> -- 获得类声明的所有方法</span></span><br></pre></td></tr></table></figure>

<h2 id="通过-Class-类获取成员变量、成员方法、接口、超类、构造方法等"><a href="#通过-Class-类获取成员变量、成员方法、接口、超类、构造方法等" class="headerlink" title="通过 Class 类获取成员变量、成员方法、接口、超类、构造方法等"></a>通过 Class 类获取成员变量、成员方法、接口、超类、构造方法等</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ys.reflex;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    <span class="comment">//公有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private say()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public work()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得类完整的名字</span></span><br><span class="line">String className = c2.getName();</span><br><span class="line">System.out.println(className);<span class="comment">//输出com.ys.reflex.Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的public类型的属性。</span></span><br><span class="line">Field[] fields = c2.getFields();</span><br><span class="line"><span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">   System.out.println(field.getName());<span class="comment">//age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的所有属性。包括私有的</span></span><br><span class="line">Field [] allFields = c2.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span>(Field field : allFields)&#123;</span><br><span class="line">    System.out.println(field.getName());<span class="comment">//name    age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的public类型的方法。这里包括 Object 类的一些方法</span></span><br><span class="line">Method [] methods = c2.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">    System.out.println(method.getName());<span class="comment">//work waid equls toString hashCode等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的所有方法。</span></span><br><span class="line">Method [] allMethods = c2.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method method : allMethods)&#123;</span><br><span class="line">    System.out.println(method.getName());<span class="comment">//work say</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得指定的属性</span></span><br><span class="line">Field f1 = c2.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">System.out.println(f1);</span><br><span class="line"><span class="comment">//获得指定的私有属性</span></span><br><span class="line">Field f2 = c2.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//启用和禁用访问安全检查的开关，值为 true，则表示反射的对象在使用时应该取消 java 语言的访问检查；反之不取消</span></span><br><span class="line">f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(f2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建这个类的一个对象</span></span><br><span class="line">Object p2 =  c2.newInstance();</span><br><span class="line"><span class="comment">//将 p2 对象的  f2 属性赋值为 Bob，f2 属性即为 私有属性 name</span></span><br><span class="line">f2.set(p2,<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"><span class="comment">//使用反射机制可以打破封装性，导致了java对象的属性不安全。</span></span><br><span class="line">System.out.println(f2.get(p2)); <span class="comment">//Bob</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法</span></span><br><span class="line">Constructor [] constructors = c2.getConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor constructor : constructors)&#123;</span><br><span class="line">    System.out.println(constructor.toString());<span class="comment">//public com.ys.reflex.Person()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="反射方法执行"><a href="#反射方法执行" class="headerlink" title="反射方法执行"></a>反射方法执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//正常的调用</span></span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        apple.setPrice(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple Price:&quot;</span> + apple.getPrice());</span><br><span class="line">        <span class="comment">//使用反射调用</span></span><br><span class="line">        Class clz = Class.forName(<span class="string">&quot;com.wyl.api.Apple&quot;</span>);</span><br><span class="line">        Method setPriceMethod = clz.getMethod(<span class="string">&quot;setPrice&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        Constructor appleConstructor = clz.getConstructor();</span><br><span class="line">        Object appleObj = appleConstructor.newInstance();</span><br><span class="line">        setPriceMethod.invoke(appleObj, <span class="number">14</span>);</span><br><span class="line">        Method getPriceMethod = clz.getMethod(<span class="string">&quot;getPrice&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple Price:&quot;</span> + getPriceMethod.invoke(appleObj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">王延领</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jingmo1924.cn/2021/09/06/java/firststage/java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">http://jingmo1924.cn/2021/09/06/java/firststage/java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jingmo1924.cn" target="_blank">王延领的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BB%8Enet%E5%88%B0java/">从net到java</a></div><div class="post_share"><div class="social-share" data-image="/images/20210903145511.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/06/java/firststage/spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"><img class="prev-cover" src="/images/20210903151436.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">spring5快速入门</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/11/java/firststage/MyBatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"><img class="next-cover" src="/images/20211109.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyBatis快速入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/07/Linux/linux中service文件/" title="linux中service 文件"><img class="cover" src="/images/2022072503.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-07</div><div class="title">linux中service 文件</div></div></a></div><div><a href="/2022/03/25/Linux/linux拉取部署git上的项目到docker/" title="linux拉取部署git上的项目到docker"><img class="cover" src="/images/20220725.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-25</div><div class="title">linux拉取部署git上的项目到docker</div></div></a></div><div><a href="/2021/10/15/java/firststage/Idea快捷键大全/" title="Idea快捷键大全"><img class="cover" src="/images/20210903150701.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-15</div><div class="title">Idea快捷键大全</div></div></a></div><div><a href="/2021/09/06/java/firststage/Docker快速入门/" title="docker快速入门"><img class="cover" src="/images/20210903150701.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-06</div><div class="title">docker快速入门</div></div></a></div><div><a href="/2021/11/09/java/firststage/MyBatis-Plus快速入门/" title="MyBatis-Plus快速入门"><img class="cover" src="/images/2022072504.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-09</div><div class="title">MyBatis-Plus快速入门</div></div></a></div><div><a href="/2021/09/06/java/firststage/spring快速入门/" title="spring5快速入门"><img class="cover" src="/images/20210903151436.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-06</div><div class="title">spring5快速入门</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">王延领</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wyl1924"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wyl1924" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://1714404171@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.</span> <span class="toc-text">1.注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.</span> <span class="toc-text">2.关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">3.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1自动类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E5%8C%85%E8%A3%85%E7%B1%BB%E8%BF%87%E6%B8%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3.包装类过渡类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">4.常量、变量、运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">4.3.</span> <span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-java%E6%B5%81%E8%BD%AC%E6%8E%A7%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">5.java流转控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">6.方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">6.2.</span> <span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">6.4.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">7.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">7.1.</span> <span class="toc-text">数组的定义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">7.2.</span> <span class="toc-text">数组的四个基本特点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E"><span class="toc-number">7.3.</span> <span class="toc-text">数组声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">7.4.</span> <span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.5.</span> <span class="toc-text">三种初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BE%B9%E7%95%8C"><span class="toc-number">7.6.</span> <span class="toc-text">数组边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E5%92%8CFor-Each-%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.7.</span> <span class="toc-text">for 和For-Each 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.8.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays-%E7%B1%BB"><span class="toc-number">7.9.</span> <span class="toc-text">Arrays 类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.</span> <span class="toc-text">8.面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">8.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E9%87%8D%E8%BD%BD-Overload"><span class="toc-number">8.2.</span> <span class="toc-text">重写(Override)与重载(Overload)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99-Override"><span class="toc-number">8.2.1.</span> <span class="toc-text">重写(Override)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-Overload"><span class="toc-number">8.2.2.</span> <span class="toc-text">重载(Overload)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">8.3.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">8.4.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">8.5.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.6.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">8.7.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85-package"><span class="toc-number">8.8.</span> <span class="toc-text">包(package)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">9.异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">异常处理的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.2.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Error%E4%B8%8EException%E5%8C%BA%E5%88%AB"><span class="toc-number">9.3.</span> <span class="toc-text">Error与Exception区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw%E4%B8%8Ethrows%E5%8C%BA%E5%88%AB"><span class="toc-number">9.4.</span> <span class="toc-text">throw与throws区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">10.</span> <span class="toc-text">10.集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.1.</span> <span class="toc-text">Collection 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.2.</span> <span class="toc-text">Set和List的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%B5%81-Stream-%E3%80%81%E6%96%87%E4%BB%B6-File-%E5%92%8CIO"><span class="toc-number">11.</span> <span class="toc-text">11.流(Stream)、文件(File)和IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InputStream-%E5%92%8C-OutputStream"><span class="toc-number">11.1.</span> <span class="toc-text">InputStream 和 OutputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reader-%E6%B5%81%E4%B8%8EWriter%E6%B5%81"><span class="toc-number">11.2.</span> <span class="toc-text">Reader 流与Writer流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95%EF%BC%9A"><span class="toc-number">11.3.</span> <span class="toc-text">创建读取目录：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">11.4.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B5%81"><span class="toc-number">11.5.</span> <span class="toc-text">缓存流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">11.6.</span> <span class="toc-text">转换流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">11.7.</span> <span class="toc-text">数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">11.8.</span> <span class="toc-text">打印流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">11.9.</span> <span class="toc-text">对象流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%85%B3%E9%97%AD%E9%A1%BA%E5%BA%8F"><span class="toc-number">11.10.</span> <span class="toc-text">流的关闭顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">12.多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.1.</span> <span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">12.2.</span> <span class="toc-text">线程的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">12.3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">12.4.</span> <span class="toc-text">线程的优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">12.5.</span> <span class="toc-text">线程方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4-daemon-%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.6.</span> <span class="toc-text">守护(daemon)线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%8C%E9%98%9F%E5%88%97-%E5%92%8C-%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81"><span class="toc-number">12.7.</span> <span class="toc-text">并发，队列 和 锁，死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="toc-number">12.8.</span> <span class="toc-text">线程通讯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">12.9.</span> <span class="toc-text">线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E6%B3%A8%E8%A7%A3"><span class="toc-number">13.</span> <span class="toc-text">13.注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="toc-number">13.1.</span> <span class="toc-text">内置注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">13.2.</span> <span class="toc-text">自定义注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E5%8F%8D%E5%B0%84"><span class="toc-number">14.</span> <span class="toc-text">14.反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">14.1.</span> <span class="toc-text">反射机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Class-%E7%B1%BB%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E8%B6%85%E7%B1%BB%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%AD%89"><span class="toc-number">14.2.</span> <span class="toc-text">通过 Class 类获取成员变量、成员方法、接口、超类、构造方法等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C"><span class="toc-number">14.3.</span> <span class="toc-text">反射方法执行</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/05/Linux/linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="linux 常用命令"><img src="/images/2020072502.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux 常用命令"/></a><div class="content"><a class="title" href="/2022/07/05/Linux/linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="linux 常用命令">linux 常用命令</a><time datetime="2022-07-05T08:22:21.000Z" title="发表于 2022-07-05 16:22:21">2022-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/07/Linux/linux%20%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/" title="linux双机热备"><img src="/images/20211111.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux双机热备"/></a><div class="content"><a class="title" href="/2022/06/07/Linux/linux%20%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/" title="linux双机热备">linux双机热备</a><time datetime="2022-06-07T08:51:47.683Z" title="发表于 2022-06-07 16:51:47">2022-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/07/Linux/linux%E4%B8%ADservice%E6%96%87%E4%BB%B6/" title="linux中service 文件"><img src="/images/2022072503.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux中service 文件"/></a><div class="content"><a class="title" href="/2022/06/07/Linux/linux%E4%B8%ADservice%E6%96%87%E4%BB%B6/" title="linux中service 文件">linux中service 文件</a><time datetime="2022-06-07T08:38:16.983Z" title="发表于 2022-06-07 16:38:16">2022-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/java/secondstage/SpringCode/" title="Spring Cloud"><img src="/images/20211109.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/2022/04/05/java/secondstage/SpringCode/" title="Spring Cloud">Spring Cloud</a><time datetime="2022-04-05T08:22:21.000Z" title="发表于 2022-04-05 16:22:21">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/java/secondstage/java%E9%AB%98%E5%B9%B6%E5%8F%91/" title="多线程"><img src="/images/20221004.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程"/></a><div class="content"><a class="title" href="/2022/04/05/java/secondstage/java%E9%AB%98%E5%B9%B6%E5%8F%91/" title="多线程">多线程</a><time datetime="2022-04-05T08:22:21.000Z" title="发表于 2022-04-05 16:22:21">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 王延领</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>