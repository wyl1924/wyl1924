<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>redis | 王延领的博客</title><meta name="keywords" content="双机热备,keepliv"><meta name="author" content="王延领"><meta name="copyright" content="王延领"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java学习笔记-从net到java">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="http://jingmo1924.cn/2022/03/28/java/secondstage/redis/index.html">
<meta property="og:site_name" content="王延领的博客">
<meta property="og:description" content="java学习笔记-从net到java">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jingmo1924.cn/images/2022072501.png">
<meta property="article:published_time" content="2022-03-28T06:40:28.848Z">
<meta property="article:modified_time" content="2022-07-29T13:30:44.260Z">
<meta property="article:author" content="王延领">
<meta property="article:tag" content="双机热备">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jingmo1924.cn/images/2022072501.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jingmo1924.cn/2022/03/28/java/secondstage/redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-29 21:30:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/2022072501.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">王延领的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-28T06:40:28.848Z" title="发表于 2022-03-28 14:40:28">2022-03-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-29T13:30:44.260Z" title="更新于 2022-07-29 21:30:44">2022-07-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BB%8Enet%E5%88%B0java/">从net到java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0-Redis介绍"><a href="#0-Redis介绍" class="headerlink" title="0.Redis介绍"></a><strong>0.Redis介绍</strong></h1><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。本质上是一个 Key-Value 类型的内存数据库，  整个数据库加载在内存当中进行操作， 定期通过异步操作把数据库数据 flush 到硬盘上进行保存</p>
<ul>
<li>不遵循SQL标准</li>
<li>不支持ACID（原子性，一致性，持久性，隔离性）</li>
<li>远超于SQL的性能(已知最快的key-value,纯内存操作)</li>
</ul>
<h1 id="1-Redis-的基本操作"><a href="#1-Redis-的基本操作" class="headerlink" title="1.Redis 的基本操作"></a><strong>1.Redis 的基本操作</strong></h1><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1.安装"></a>1.1.安装</h2><p>教程地址：<a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-install.html">菜鸟教程</a></p>
<h1 id="2-Redis基本数据存储类型"><a href="#2-Redis基本数据存储类型" class="headerlink" title="2.Redis基本数据存储类型"></a><strong>2.Redis基本数据存储类型</strong></h1><p>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构     </p>
<p>value的数据结构：     </p>
<pre><code>* 字符串类型 string         
*  哈希类型 hash ： map格式           
* 列表类型 list ： linkedlist格式。支持重复元素         
*  集合类型 set  ： 不允许重复元素         
*  有序集合类型 sortedset：不允许重复元素，且元素有顺序
</code></pre>
<h2 id="2-1String类型"><a href="#2-1String类型" class="headerlink" title="2.1String类型"></a>2.1String类型</h2><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<p>SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p>
<ul>
<li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li>
</ul>
<p>字符串对象的内部编码（encoding）有 3 种 ：<strong>int、raw和 embstr</strong>。</p>
<p><img src="/images/img/blog/image-20220620102656145.png" alt="image-20220620102656145"></p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用<code>long</code>类型来表示，那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面（将<code>void*</code>转换成 long），并将字符串对象的编码设置为<code>int</code>。</p>
<p><img src="/images/img/blog/image-20220620102752438.png" alt="image-20220620102752438"></p>
<p>如果字符串对象保存的是一个字符串，并且这个字符申的长度小于等于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>embstr</code>， <code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式：</p>
<p><img src="/images/img/blog/image-20220620102817386.png" alt="image-20220620102817386"></p>
<p>如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>raw</code>：</p>
<p><img src="/images/img/blog/image-20220620102829176.png" alt="image-20220620102829176"></p>
<p>注意，embstr 编码和 raw 编码的边界在 redis 不同版本中是不一样的：</p>
<ul>
<li>redis 2.+ 是 32 字节</li>
<li>redis 3.0-4.0 是 39 字节</li>
<li>redis 5.0 是 44 字节</li>
</ul>
<p>可以看到<code>embstr</code>和<code>raw</code>编码都会使用<code>SDS</code>来保存值，但不同之处在于<code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>，而<code>raw</code>编码会通过调用两次内存分配函数来分别分配两块空间来保存<code>redisObject</code>和<code>SDS</code>。Redis这样做会有很多好处：</p>
<ul>
<li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次；</li>
<li>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数；</li>
<li>因为<code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</li>
</ul>
<p>但是 embstr 也有缺点的：</p>
<ul>
<li><p>如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以<strong>embstr编码的字符串对象实际上是只读的</strong>，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。</p>
</li>
<li><p>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</p>
</li>
<li><p>存储数据的格式：一个存储空间保存一个数据</p>
</li>
<li><p>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</p>
</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">set</span> <span class="selector-tag">key</span> <span class="selector-tag">value</span>   添加/修改数据</span><br><span class="line"><span class="selector-tag">get</span> <span class="selector-tag">key</span>          获取数据</span><br><span class="line"><span class="selector-tag">del</span> <span class="selector-tag">key</span>          删除数据</span><br><span class="line"><span class="selector-tag">mset</span> <span class="selector-tag">key1</span> <span class="selector-tag">value1</span> <span class="selector-tag">key2</span> <span class="selector-tag">value2</span> …   添加/修改多个数据</span><br><span class="line"><span class="selector-tag">mget</span> <span class="selector-tag">key1</span> <span class="selector-tag">key2</span> …                  获取多个数据</span><br><span class="line"><span class="selector-tag">strlen</span> <span class="selector-tag">key</span>       获取数据字符个数（字符串长度）</span><br><span class="line"><span class="selector-tag">append</span> <span class="selector-tag">key</span> <span class="selector-tag">value</span>  追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</span><br><span class="line"></span><br><span class="line">扩展操作：</span><br><span class="line">设置数值数据增加指定范围的值</span><br><span class="line"><span class="selector-tag">incr</span> <span class="selector-tag">key</span></span><br><span class="line"><span class="selector-tag">incrby</span> <span class="selector-tag">key</span> <span class="selector-tag">increment</span></span><br><span class="line"><span class="selector-tag">incrbyfloat</span> <span class="selector-tag">key</span> <span class="selector-tag">increment</span></span><br><span class="line"></span><br><span class="line">设置数值数据减少指定范围的值</span><br><span class="line"><span class="selector-tag">decr</span> <span class="selector-tag">key</span></span><br><span class="line"><span class="selector-tag">decrby</span> <span class="selector-tag">key</span> <span class="selector-tag">increment</span></span><br><span class="line"></span><br><span class="line">设置数据具有指定的生命周期</span><br><span class="line"><span class="selector-tag">setex</span> <span class="selector-tag">key</span> <span class="selector-tag">seconds</span> <span class="selector-tag">value</span></span><br><span class="line"><span class="selector-tag">psetex</span> <span class="selector-tag">key</span> <span class="selector-tag">milliseconds</span> <span class="selector-tag">value</span></span><br><span class="line">过期操作</span><br><span class="line"><span class="selector-tag">EXPIRE</span> <span class="selector-tag">key</span> <span class="selector-tag">time</span>    在<span class="selector-tag">time</span>秒后获取 </span><br><span class="line"><span class="selector-tag">set</span> <span class="selector-tag">key</span> <span class="selector-tag">value</span> <span class="selector-tag">EX</span> <span class="selector-tag">time</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>使用 String 来缓存对象有两种方式：</p>
<ul>
<li>直接缓存整个对象的 JSON，命令例子： <code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#39;</code>。</li>
<li>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code>。</li>
</ul>
<h4 id="常规计数"><a href="#常规计数" class="headerlink" title="常规计数"></a>常规计数</h4><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<p>比如计算文章的阅读量：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 初始化文章的阅读量</span></span><br><span class="line"><span class="quote">&gt; SET aritcle:readcount:1001 0</span></span><br><span class="line">OK</span><br><span class="line"><span class="section">#阅读量+1</span></span><br><span class="line"><span class="quote">&gt; INCR aritcle:readcount:1001</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="section">#阅读量+1</span></span><br><span class="line"><span class="quote">&gt; INCR aritcle:readcount:1001</span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="section">#阅读量+1</span></span><br><span class="line"><span class="quote">&gt; INCR aritcle:readcount:1001</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="section"># 获取对应文章的阅读量</span></span><br><span class="line"><span class="quote">&gt; GET aritcle:readcount:1001</span></span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>

<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
<p>一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> lock_key unique_value NX PX <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lock_key 就是 key 键；</li>
<li>unique_value 是客户端生成的唯一的标识；</li>
<li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li>
<li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li>
</ul>
<p>而解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p>
<p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p>
<h4 id="共享-Session-信息"><a href="#共享-Session-信息" class="headerlink" title="共享 Session 信息"></a>共享 Session 信息</h4><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。</p>
<p>分布式系统单独存储 Session 流程图：</p>
<p><img src="/images/img/blog/image-20220620102852753.png" alt="image-20220620102852753"></p>
<p>因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p>
<p>分布式系统使用同一个 Redis 存储 Session 流程图：</p>
<p><img src="/images/img/blog/image-20220620102905750.png" alt="image-20220620102905750"></p>
<h2 id="2-2Hash类型"><a href="#2-2Hash类型" class="headerlink" title="2.2Hash类型"></a>2.2Hash类型</h2><h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p>
<ul>
<li><p>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</p>
</li>
<li><p> 需要的存储结构：一个存储空间保存多个键值对数据</p>
</li>
<li><p> hash类型：底层使用哈希表结构实现数据存储</p>
</li>
</ul>
<p>  <em>hash存储结构优化：如果field数量较少，存储结构优化为类数组结构，如果field数量较多，存储结构使用HashMap结构。</em></p>
<p>  <em>hash类型数据操作注意事项：①hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到， 对应的值为（nil）。②hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问 瓶颈。</em></p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">hset</span> <span class="selector-tag">key</span> <span class="selector-tag">field</span> <span class="selector-tag">value</span>   添加/修改数据</span><br><span class="line"><span class="selector-tag">hget</span> <span class="selector-tag">key</span> <span class="selector-tag">field</span></span><br><span class="line"><span class="selector-tag">hgetall</span> <span class="selector-tag">key</span>              获取数据</span><br><span class="line"><span class="selector-tag">hdel</span> <span class="selector-tag">key</span> <span class="selector-tag">field1</span> <span class="selector-attr">[field2]</span> 删除数据</span><br><span class="line"><span class="selector-tag">hmset</span> <span class="selector-tag">key</span> <span class="selector-tag">field1</span> <span class="selector-tag">value1</span> <span class="selector-tag">field2</span> <span class="selector-tag">value2</span> …    添加/修改多个数据</span><br><span class="line"><span class="selector-tag">hmget</span> <span class="selector-tag">key</span> <span class="selector-tag">field1</span> <span class="selector-tag">field2</span> …                   获取多个数据</span><br><span class="line"><span class="selector-tag">hlen</span> <span class="selector-tag">key</span>                                 获取哈希表中字段的数量</span><br><span class="line"><span class="selector-tag">hexists</span> <span class="selector-tag">key</span> <span class="selector-tag">field</span>                     获取哈希表中是否存在指定的字段</span><br><span class="line"></span><br><span class="line">扩展操作：</span><br><span class="line">获取哈希表中所有的字段名或字段值</span><br><span class="line"><span class="selector-tag">hkeys</span> <span class="selector-tag">key</span></span><br><span class="line"><span class="selector-tag">hvals</span> <span class="selector-tag">key</span></span><br><span class="line"></span><br><span class="line">设置指定字段的数值数据增加指定范围的值</span><br><span class="line"><span class="selector-tag">hincrby</span> <span class="selector-tag">key</span> <span class="selector-tag">field</span> <span class="selector-tag">increment</span></span><br><span class="line"><span class="selector-tag">hincrbyfloat</span> <span class="selector-tag">key</span> <span class="selector-tag">field</span> <span class="selector-tag">increment</span></span><br><span class="line"></span><br><span class="line">为哈希表中不存在的的字段赋值</span><br><span class="line"><span class="selector-tag">hsetnx</span> <span class="selector-tag">key</span> <span class="selector-tag">field</span> <span class="selector-tag">value</span></span><br></pre></td></tr></table></figure>

<h3 id="业务场景：-1"><a href="#业务场景：-1" class="headerlink" title="业务场景："></a>业务场景：</h3><h4 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h4><p>Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。</p>
<p>我们以用户信息为例</p>
<p>我们可以使用如下命令，将用户对象的信息存储到 Hash 类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 存储一个哈希表<span class="selector-tag">uid</span>:<span class="selector-tag">1</span>的键值</span><br><span class="line">&gt; <span class="selector-tag">HSET</span> <span class="selector-tag">uid</span>:<span class="selector-tag">1</span> <span class="selector-tag">name</span> <span class="selector-tag">Tom</span> <span class="selector-tag">age</span> <span class="selector-tag">15</span></span><br><span class="line"><span class="selector-tag">2</span></span><br><span class="line"># 存储一个哈希表<span class="selector-tag">uid</span>:<span class="selector-tag">2</span>的键值</span><br><span class="line">&gt; <span class="selector-tag">HSET</span> <span class="selector-tag">uid</span>:<span class="selector-tag">2</span> <span class="selector-tag">name</span> <span class="selector-tag">Jerry</span> <span class="selector-tag">age</span> <span class="selector-tag">13</span></span><br><span class="line"><span class="selector-tag">2</span></span><br><span class="line"># 获取哈希表用户<span class="selector-tag">id</span>为<span class="selector-tag">1</span>中所有的键值</span><br><span class="line">&gt; <span class="selector-tag">HGETALL</span> <span class="selector-tag">uid</span>:<span class="selector-tag">1</span></span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;Tom&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;15&quot;</span><br></pre></td></tr></table></figure>

<p>Redis Hash 存储其结构如下图：</p>
<p><img src="/images/img/blog/image-20220620103328419.png" alt="image-20220620103328419"></p>
<p>在介绍 String 类型的应用场景时有所介绍，String + Json也是存储对象的一种方式，那么存储对象时，到底用 String + json 还是用 Hash 呢？</p>
<p>一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。</p>
<h2 id="2-3List"><a href="#2-3List" class="headerlink" title="2.3List"></a>2.3List</h2><h3 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p>
<ul>
<li> 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li>
<li> 需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li>
<li> list类型：保存多个数据，底层使用双向链表存储结构实现<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">添加&#x2F;修改数据</span><br><span class="line">lpush key value1 [value2] ……</span><br><span class="line">rpush key value1 [value2] ……</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">lrange key start stop</span><br><span class="line">lindex key index</span><br><span class="line">llen key</span><br><span class="line"></span><br><span class="line">获取并移除数据</span><br><span class="line">lpop key</span><br><span class="line">rpop key</span><br><span class="line"></span><br><span class="line">扩展操作</span><br><span class="line">规定时间内获取并移除数据</span><br><span class="line">blpop key1 [key2] timeout</span><br><span class="line">brpop key1 [key2] timeout</span><br><span class="line">brpoplpush source destination timeout</span><br><span class="line"></span><br><span class="line">移除指定数据</span><br><span class="line">lrem key count value</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p>
<p>Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。我们先来了解下基于 List 的消息队列实现方法，后面在介绍 Stream 数据类型时候，在详细说说 Stream。</p>
<p><em>1、如何满足消息保序需求？</em></p>
<p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p>
<p>List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。</p>
<p><img src="/images/img/blog/image-20220620103004876.png" alt="image-20220620103004876"></p>
<ul>
<li>生产者使用 <code>LPUSH key value[value...]</code> 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</li>
<li>消费者使用 <code>RPOP key</code> 依次读取队列的消息，先进先出。</li>
</ul>
<p>不过，在消费者读取数据时，有一个潜在的性能风险点。</p>
<p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code> 命令（比如使用一个while(1)循环）。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环。</p>
<p>所以，即使没有新消息写入List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。</p>
<p>为了解决这个问题，Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p>
<p><img src="/images/img/blog/image-20220620103018102.png" alt="image-20220620103018102"></p>
<p><em>2、如何处理重复的消息？</em></p>
<p>消费者要实现重复消息的判断，需要 2 个方面的要求：</p>
<ul>
<li>每个消息都有一个全局的 ID。</li>
<li>消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</li>
</ul>
<p>但是 <strong>List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID</strong>，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p>
<p>例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 99 的消息插入了消息队列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LPUSH mq <span class="string">&quot;111000102:stock:99&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p><em>3、如何保证消息可靠性？</em></p>
<p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p>
<p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</p>
<p>这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p>
<p>好了，到这里可以知道基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。</p>
<ul>
<li>消息保序：使用 LPUSH + RPOP；</li>
<li>阻塞读取：使用 BRPOP；</li>
<li>重复消息处理：生产者自行实现全局唯一 ID；</li>
<li>消息的可靠性：使用 BRPOPLPUSH</li>
</ul>
<blockquote>
<p>List 作为消息队列有什么缺陷？</p>
</blockquote>
<p><strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。</p>
<p>要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 <strong>List 类型并不支持消费组的实现</strong>。</p>
<p>这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。</p>
<h2 id="2-4set类型"><a href="#2-4set类型" class="headerlink" title="2.4set类型"></a>2.4set类型</h2><h3 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li><p>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</p>
</li>
<li><p>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</p>
</li>
<li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p>
</li>
<li><p>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p>
</li>
<li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</p>
</li>
</ul>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sadd</span> <span class="selector-tag">key</span> <span class="selector-tag">member1</span> <span class="selector-attr">[member2]</span>     添加数据</span><br><span class="line"><span class="selector-tag">smembers</span> <span class="selector-tag">key</span>                   获取全部数据</span><br><span class="line"><span class="selector-tag">srem</span> <span class="selector-tag">key</span> <span class="selector-tag">member1</span> <span class="selector-attr">[member2]</span>     删除数据</span><br><span class="line"><span class="selector-tag">scard</span> <span class="selector-tag">key</span>                      获取集合数据总量</span><br><span class="line"><span class="selector-tag">sismember</span> <span class="selector-tag">key</span> <span class="selector-tag">member</span>           判断集合中是否包含指定数据</span><br><span class="line"></span><br><span class="line">扩展操作</span><br><span class="line">随机获取集合中指定数量的数据</span><br><span class="line"><span class="selector-tag">srandmember</span> <span class="selector-tag">key</span> <span class="selector-attr">[count]</span></span><br><span class="line"></span><br><span class="line">随机获取集合中的某个数据并将该数据移出集合</span><br><span class="line"><span class="selector-tag">spop</span> <span class="selector-tag">key</span> <span class="selector-attr">[count]</span></span><br><span class="line"></span><br><span class="line">求两个集合的交、并、差集</span><br><span class="line"><span class="selector-tag">sinter</span> <span class="selector-tag">key1</span> <span class="selector-attr">[key2]</span> </span><br><span class="line"><span class="selector-tag">sunion</span> <span class="selector-tag">key1</span> <span class="selector-attr">[key2]</span> </span><br><span class="line"><span class="selector-tag">sdiff</span> <span class="selector-tag">key1</span> <span class="selector-attr">[key2]</span></span><br><span class="line"></span><br><span class="line">求两个集合的交、并、差集并存储到指定集合中</span><br><span class="line"><span class="selector-tag">sinterstore</span> <span class="selector-tag">destination</span> <span class="selector-tag">key1</span> <span class="selector-attr">[key2]</span> </span><br><span class="line"><span class="selector-tag">sunionstore</span> <span class="selector-tag">destination</span> <span class="selector-tag">key1</span> <span class="selector-attr">[key2]</span> </span><br><span class="line"><span class="selector-tag">sdiffstore</span> <span class="selector-tag">destination</span> <span class="selector-tag">key1</span> <span class="selector-attr">[key2]</span></span><br><span class="line"></span><br><span class="line">将指定数据从原始集合中移动到目标集合中</span><br><span class="line"><span class="selector-tag">smove</span> <span class="selector-tag">source</span> <span class="selector-tag">destination</span> <span class="selector-tag">member</span></span><br></pre></td></tr></table></figure>

<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<p>因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>
<p>但是要提醒你一下，这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p>
<h4 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h4><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</p>
<p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uid:1 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># uid:2 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># uid:3 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p><code>uid:1</code> 取消了对 article:1 文章点赞。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">SREM</span> <span class="selector-tag">article</span>:<span class="selector-tag">1</span> <span class="selector-tag">uid</span>:<span class="selector-tag">1</span></span><br><span class="line">(integer) <span class="selector-tag">1</span></span><br></pre></td></tr></table></figure>

<p>获取 article:1 文章所有点赞用户 :</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SMEMBERS <span class="selector-tag">article</span>:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;uid:3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;uid:2&quot;</span></span><br></pre></td></tr></table></figure>

<p>获取 article:1 文章的点赞用户数量：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">SCARD</span> <span class="selector-tag">article</span>:<span class="selector-tag">1</span></span><br><span class="line">(integer) <span class="selector-tag">2</span></span><br></pre></td></tr></table></figure>

<p>判断用户 <code>uid:1</code> 是否对文章 article:1 点赞了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SISMEMBER article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 0  <span class="comment"># 返回0说明没点赞，返回1则说明点赞了</span></span><br></pre></td></tr></table></figure>

<h4 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h4><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p>key 可以是用户id，value 则是已关注的公众号的id。</p>
<p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uid:1 用户关注公众号 id 为 5、6、7、8、9</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SADD uid:1 5 6 7 8 9</span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> uid:2  用户关注公众号 id 为 7、8、9、10、11</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SADD uid:2 7 8 9 10 11</span></span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<p><code>uid:1</code> 和 <code>uid:2</code> 共同关注的公众号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取共同关注</span></span><br><span class="line">&gt; SINTER uid:1 uid:2</span><br><span class="line">1) <span class="string">&quot;7&quot;</span></span><br><span class="line">2) <span class="string">&quot;8&quot;</span></span><br><span class="line">3) <span class="string">&quot;9&quot;</span></span><br></pre></td></tr></table></figure>

<p>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SDIFF uid:1 uid:2</span><br><span class="line">1) <span class="string">&quot;5&quot;</span></span><br><span class="line">2) <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>

<p>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SISMEMBER uid:1 5</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 返回0，说明关注了</span></span><br><span class="line">&gt; SISMEMBER uid:2 5</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 返回0，说明没关注</span></span><br></pre></td></tr></table></figure>

<h4 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h4><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<p>key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱 ：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;SADD lucky Tom <span class="keyword">Jerry </span><span class="keyword">John </span>Sean Marry Lindy Sary Mark</span><br><span class="line">(integer) <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>如果允许重复中奖，可以使用 SRANDMEMBER 命令。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抽取 1 个一等奖：</span></span><br><span class="line">&gt; <span class="keyword">SRANDMEMBER </span>lucky <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Tom&quot;</span></span><br><span class="line"><span class="comment"># 抽取 2 个二等奖：</span></span><br><span class="line">&gt; <span class="keyword">SRANDMEMBER </span>lucky <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Mark&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Jerry&quot;</span></span><br><span class="line"><span class="comment"># 抽取 3 个三等奖：</span></span><br><span class="line">&gt; <span class="keyword">SRANDMEMBER </span>lucky <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Sary&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Tom&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;Jerry&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果不允许重复中奖，可以使用 SPOP 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抽取一等奖1个</span></span><br><span class="line">&gt; SPOP lucky 1</span><br><span class="line">1) <span class="string">&quot;Sary&quot;</span></span><br><span class="line"><span class="comment"># 抽取二等奖2个</span></span><br><span class="line">&gt; SPOP lucky 2</span><br><span class="line">1) <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">2) <span class="string">&quot;Mark&quot;</span></span><br><span class="line"><span class="comment"># 抽取三等奖3个</span></span><br><span class="line">&gt; SPOP lucky 3</span><br><span class="line">1) <span class="string">&quot;John&quot;</span></span><br><span class="line">2) <span class="string">&quot;Sean&quot;</span></span><br><span class="line">3) <span class="string">&quot;Lindy&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5sorted-set类型"><a href="#2-5sorted-set类型" class="headerlink" title="2.5sorted_set类型"></a>2.5sorted_set类型</h2><ul>
<li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p>
</li>
<li><p>需要的存储结构：新的存储模型，可以保存可排序的数据</p>
</li>
<li><p>sorted_set类型：在set的存储结构基础上添加可排序字段</p>
</li>
</ul>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">zadd</span> <span class="selector-tag">key</span> <span class="selector-tag">score1</span> <span class="selector-tag">member1</span> <span class="selector-attr">[score2 member2]</span>    添加数据</span><br><span class="line"><span class="selector-tag">zrange</span> <span class="selector-tag">key</span> <span class="selector-tag">start</span> <span class="selector-tag">stop</span> <span class="selector-attr">[WITHSCORES]</span></span><br><span class="line"><span class="selector-tag">zrevrange</span> <span class="selector-tag">key</span> <span class="selector-tag">start</span> <span class="selector-tag">stop</span> <span class="selector-attr">[WITHSCORES]</span>       获取全部数据</span><br><span class="line"><span class="selector-tag">zrem</span> <span class="selector-tag">key</span> <span class="selector-tag">member</span> <span class="selector-attr">[member ...]</span>                删除数据</span><br><span class="line"><span class="selector-tag">zrangebyscore</span> <span class="selector-tag">key</span> <span class="selector-tag">min</span> <span class="selector-tag">max</span> <span class="selector-attr">[WITHSCORES]</span> <span class="selector-attr">[LIMIT]</span></span><br><span class="line"><span class="selector-tag">zrevrangebyscore</span> <span class="selector-tag">key</span> <span class="selector-tag">max</span> <span class="selector-tag">min</span> <span class="selector-attr">[WITHSCORES]</span>   按条件获取数据</span><br><span class="line"><span class="selector-tag">zremrangebyrank</span> <span class="selector-tag">key</span> <span class="selector-tag">start</span> <span class="selector-tag">stop</span></span><br><span class="line"><span class="selector-tag">zremrangebyscore</span> <span class="selector-tag">key</span> <span class="selector-tag">min</span> <span class="selector-tag">max</span>                条件删除数据</span><br><span class="line"><span class="selector-tag">zcard</span> <span class="selector-tag">key</span></span><br><span class="line"><span class="selector-tag">zcount</span> <span class="selector-tag">key</span> <span class="selector-tag">min</span> <span class="selector-tag">max</span>                          获取集合数据总量</span><br><span class="line"><span class="selector-tag">zinterstore</span> <span class="selector-tag">destination</span> <span class="selector-tag">numkeys</span> <span class="selector-tag">key</span> <span class="selector-attr">[key ...]</span></span><br><span class="line"><span class="selector-tag">zunionstore</span> <span class="selector-tag">destination</span> <span class="selector-tag">numkeys</span> <span class="selector-tag">key</span> <span class="selector-attr">[key ...]</span>    集合交、并操作</span><br><span class="line"></span><br><span class="line">扩展操作</span><br><span class="line">获取数据对应的索引（排名）</span><br><span class="line"><span class="selector-tag">zrank</span> <span class="selector-tag">key</span> <span class="selector-tag">member</span></span><br><span class="line"><span class="selector-tag">zrevrank</span> <span class="selector-tag">key</span> <span class="selector-tag">member</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">score</span>值获取与修改</span><br><span class="line"><span class="selector-tag">zscore</span> <span class="selector-tag">key</span> <span class="selector-tag">member</span></span><br><span class="line"><span class="selector-tag">zincrby</span> <span class="selector-tag">key</span> <span class="selector-tag">increment</span> <span class="selector-tag">member</span></span><br></pre></td></tr></table></figure>

<h3 id="业务场景：-2"><a href="#业务场景：-2" class="headerlink" title="业务场景："></a>业务场景：</h3><p>redis 应用于计数器组合排序功能对应的排名。</p>
<p>redis 应用于定时任务执行顺序管理或任务过期管理。</p>
<p>任务/消息权重设定应用当任务或者消息待处理，形成了任务队列或消息队列时，对于高优先级的任务要保障对其优先处理。</p>
<h2 id="2-6geo-类型"><a href="#2-6geo-类型" class="headerlink" title="2.6geo 类型"></a>2.6geo 类型</h2><p>GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p>
<p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中。</p>
<h3 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p>
<p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。</p>
<p>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求。</p>
<h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 <span class="selector-tag">key</span> 中。</span><br><span class="line"><span class="selector-tag">GEOADD</span> <span class="selector-tag">key</span> <span class="selector-tag">longitude</span> <span class="selector-tag">latitude</span> <span class="selector-tag">member</span> <span class="selector-attr">[longitude latitude member ...]</span></span><br><span class="line"></span><br><span class="line"># 从给定的 <span class="selector-tag">key</span> 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 <span class="selector-tag">nil</span>。</span><br><span class="line"><span class="selector-tag">GEOPOS</span> <span class="selector-tag">key</span> <span class="selector-tag">member</span> <span class="selector-attr">[member ...]</span></span><br><span class="line"></span><br><span class="line"># 返回两个给定位置之间的距离。</span><br><span class="line"><span class="selector-tag">GEODIST</span> <span class="selector-tag">key</span> <span class="selector-tag">member1</span> <span class="selector-tag">member2</span> <span class="selector-attr">[m|km|ft|mi]</span></span><br><span class="line"></span><br><span class="line"># 根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span><br><span class="line"><span class="selector-tag">GEORADIUS</span> <span class="selector-tag">key</span> <span class="selector-tag">longitude</span> <span class="selector-tag">latitude</span> <span class="selector-tag">radius</span> <span class="selector-tag">m</span>|<span class="selector-tag">km</span>|<span class="selector-tag">ft</span>|<span class="selector-tag">mi</span> <span class="selector-attr">[WITHCOORD]</span> <span class="selector-attr">[WITHDIST]</span> <span class="selector-attr">[WITHHASH]</span> <span class="selector-attr">[COUNT count]</span> <span class="selector-attr">[ASC|DESC]</span> <span class="selector-attr">[STORE key]</span> <span class="selector-attr">[STOREDIST key]</span></span><br></pre></td></tr></table></figure>

<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>这里以滴滴叫车的场景为例，介绍下具体如何使用 GEO 命令：GEOADD 和 GEORADIUS 这两个命令。</p>
<p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。</p>
<p>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">GEOADD</span> <span class="selector-tag">cars</span>:<span class="selector-tag">locations</span> <span class="selector-tag">116</span><span class="selector-class">.034579</span> <span class="selector-tag">39</span><span class="selector-class">.030452</span> <span class="selector-tag">33</span></span><br></pre></td></tr></table></figure>

<p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。</p>
<p>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS cars:locations <span class="number">116.054579</span> <span class="number">39.030452</span> <span class="number">5</span> km <span class="keyword">ASC</span> COUNT <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7HyperLogLog"><a href="#2-7HyperLogLog" class="headerlink" title="2.7HyperLogLog"></a>2.7HyperLogLog</h2><p>HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。</p>
<p>所以，简单来说 HyperLogLog <strong>提供不精确的去重计数</strong>。</p>
<p>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数</strong>，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p>
<p>这什么概念？举个例子给大家对比一下。</p>
<p>用 Java 语言来说，一般 long 类型占用 8 字节，而 1 字节有 8 位，即：1 byte = 8 bit，即 long 数据类型最大可以表示的数是：<code>2^63-1</code>。对应上面的<code>2^64</code>个数，假设此时有<code>2^63-1</code>这么多个数，从 <code>0 ~ 2^63-1</code>，按照<code>long</code>以及<code>1k = 1024 字节</code>的规则来计算内存总数，就是：<code>((2^63-1) * 8/1024)K</code>，这是很庞大的一个数，存储空间远远超过<code>12K</code>，而 <code>HyperLogLog</code> 却可以用 <code>12K</code> 就能统计完。</p>
<h3 id="内部实现-5"><a href="#内部实现-5" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>HyperLogLog 的实现涉及到很多数学问题，太费脑子了，我也没有搞懂，如果你想了解一下，课下可以看看这个：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a>。</p>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a><strong>常见命令</strong></h3><p>HyperLogLog 命令很少，就三个。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFADD key element [element ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>

<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><h4 id="百万级网页-UV-计数"><a href="#百万级网页-UV-计数" class="headerlink" title="百万级网页 UV 计数"></a>百万级网页 UV 计数</h4><p>Redis HyperLogLog 优势在于只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p>
<p>所以，非常适合统计百万级以上的网页 UV 的场景。</p>
<p>在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PFADD</span> page1:uv user1 user2 user3 user4 user5</span><br></pre></td></tr></table></figure>

<p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT page1:uv</span><br></pre></td></tr></table></figure>

<p>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p>
<p>这也就意味着，你使用 HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。</p>
<h2 id="2-8Bitmap"><a href="#2-8Bitmap" class="headerlink" title="2.8Bitmap"></a>2.8Bitmap</h2><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p>
<p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p>
<h3 id="内部实现-6"><a href="#内部实现-6" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p>
<h3 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>bitmap 基本操作：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 设置值，其中<span class="selector-tag">value</span>只能是 <span class="selector-tag">0</span> 和 <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">SETBIT</span> <span class="selector-tag">key</span> <span class="selector-tag">offset</span> <span class="selector-tag">value</span></span><br><span class="line"></span><br><span class="line"># 获取值</span><br><span class="line"><span class="selector-tag">GETBIT</span> <span class="selector-tag">key</span> <span class="selector-tag">offset</span></span><br><span class="line"></span><br><span class="line"># 获取指定范围内值为 <span class="selector-tag">1</span> 的个数</span><br><span class="line"># <span class="selector-tag">start</span> 和 <span class="selector-tag">end</span> 以字节为单位</span><br><span class="line"><span class="selector-tag">BITCOUNT</span> <span class="selector-tag">key</span> <span class="selector-tag">start</span> <span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>

<p>bitmap 运算操作：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">BitMap</span>间的运算</span><br><span class="line"># <span class="selector-tag">operations</span> 位移操作符，枚举值</span><br><span class="line">  <span class="selector-tag">AND</span> 与运算 <span class="selector-tag">&amp;</span></span><br><span class="line">  <span class="selector-tag">OR</span> 或运算 |</span><br><span class="line">  <span class="selector-tag">XOR</span> 异或 ^</span><br><span class="line">  <span class="selector-tag">NOT</span> 取反 ~</span><br><span class="line"># <span class="selector-tag">result</span> 计算的结果，会存储在该<span class="selector-tag">key</span>中</span><br><span class="line"># <span class="selector-tag">key1</span> … <span class="selector-tag">keyn</span> 参与运算的<span class="selector-tag">key</span>，可以有多个，空格分割，<span class="selector-tag">not</span>运算只能一个<span class="selector-tag">key</span></span><br><span class="line"># 当 <span class="selector-tag">BITOP</span> 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <span class="selector-tag">0</span>。返回值是保存到 <span class="selector-tag">destkey</span> 的字符串的长度（以字节<span class="selector-tag">byte</span>为单位），和输入 <span class="selector-tag">key</span> 中最长的字符串长度相等。</span><br><span class="line"><span class="selector-tag">BITOP</span> <span class="selector-attr">[operations]</span> <span class="selector-attr">[result]</span> <span class="selector-attr">[key1]</span> <span class="selector-attr">[keyn…]</span></span><br><span class="line"></span><br><span class="line"># 返回指定<span class="selector-tag">key</span>中第一次出现指定<span class="selector-tag">value</span>(<span class="number">0</span>/<span class="number">1</span>)的位置</span><br><span class="line"><span class="selector-tag">BITPOS</span> <span class="selector-attr">[key]</span> <span class="selector-attr">[value]</span></span><br></pre></td></tr></table></figure>

<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><p>Bitmap 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 0 和 1 两种，在记录海量数据时，Bitmap 能够有效地节省内存空间。</p>
<h4 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h4><p>在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p>
<p>签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</p>
<p>假设我们要统计 ID 100 的用户在 2022 年 6 月份的签到情况，就可以按照下面的步骤进行操作。</p>
<p>第一步，执行下面的命令，记录该用户 6 月 3 号已签到。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT uid:<span class="built_in">sign</span>:<span class="number">100</span>:<span class="number">202206</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>第二步，检查该用户 6 月 3 日是否签到。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT uid:<span class="built_in">sign</span>:<span class="number">100</span>:<span class="number">202206</span> <span class="number">2</span> </span><br></pre></td></tr></table></figure>

<p>第三步，统计该用户在 6 月份的签到次数。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT uid:<span class="built_in">sign</span>:<span class="number">100</span>:<span class="number">202206</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就知道该用户在 6 月份的签到情况了。</p>
<blockquote>
<p>如何统计这个月首次打卡时间呢？</p>
</blockquote>
<p>Redis 提供了 <code>BITPOS key bitValue [start] [end]</code>指令，返回数据表示 Bitmap 中第一个值为 <code>bitValue</code> 的 offset 位置。</p>
<p>在默认情况下， 命令将检测整个位图， 用户可以通过可选的 <code>start</code> 参数和 <code>end</code> 参数指定要检测的范围。所以我们可以通过执行这条命令来获取 userID = 100 在 2022 年 6 月份<strong>首次打卡</strong>日期：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITPOS uid:<span class="built_in">sign</span>:<span class="number">100</span>:<span class="number">202206</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，因为 offset 从 0 开始的，所以我们需要将返回的 value + 1 。</p>
<h4 id="判断用户登陆态"><a href="#判断用户登陆态" class="headerlink" title="判断用户登陆态"></a>判断用户登陆态</h4><p>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p>
<p>只需要一个 key = login_status 表示存储用户登陆状态集合数据， 将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 <code>GETBIT</code>判断对应的用户是否在线。 50000 万 用户只需要 6 MB 的空间。</p>
<p>假如我们要判断 ID = 10086 的用户的登陆情况：</p>
<p>第一步，执行以下指令，表示用户已登录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 10086 1</span><br></pre></td></tr></table></figure>

<p>第二步，检查该用户是否登陆，返回值 1 表示已登录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT login_status 10086</span><br></pre></td></tr></table></figure>

<p>第三步，登出，将 offset 对应的 value 设置成 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 10086 0</span><br></pre></td></tr></table></figure>

<h4 id="连续签到用户总数"><a href="#连续签到用户总数" class="headerlink" title="连续签到用户总数"></a>连续签到用户总数</h4><p>如何统计出这连续 7 天连续打卡用户总数呢？</p>
<p>我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。</p>
<p>key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。</p>
<p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit = 1 就说明该用户 7 天连续打卡。</p>
<p>结果保存到一个新 Bitmap 中，我们再通过 <code>BITCOUNT</code> 统计 bit = 1 的个数便得到了连续打卡 3 天的用户总数了。</p>
<p>Redis 提供了 <code>BITOP operation destkey key [key ...]</code>这个指令用于对一个或者多个 key 的 Bitmap 进行位元操作。</p>
<ul>
<li><code>opration</code> 可以是 <code>and</code>、<code>OR</code>、<code>NOT</code>、<code>XOR</code>。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</li>
</ul>
<p>举个例子，比如将三个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，接着对 destmap 执行 BITCOUNT 统计。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与操作</span></span><br><span class="line"><span class="keyword">BITOP </span><span class="keyword">AND </span>destmap <span class="keyword">bitmap:01 </span><span class="keyword">bitmap:02 </span><span class="keyword">bitmap:03</span></span><br><span class="line"><span class="keyword"># </span>统计 <span class="keyword">bit </span>位 =  <span class="number">1</span> 的个数</span><br><span class="line"><span class="keyword">BITCOUNT </span>destmap</span><br></pre></td></tr></table></figure>

<p>即使一天产生一个亿的数据，Bitmap 占用的内存也不大，大约占 12 MB 的内存（10^8/8/1024/1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。</p>
<h2 id="2-9Zset"><a href="#2-9Zset" class="headerlink" title="2.9Zset"></a>2.9Zset</h2><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。</p>
<p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/zset.png" alt="img"></p>
<h3 id="内部实现-7"><a href="#内部实现-7" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p>
<h3 id="常用命令-7"><a href="#常用命令-7" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>Zset 常用操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 往有序集合key中加入带分值元素</span></span><br><span class="line">ZADD key score member [[score member]...]   </span><br><span class="line"><span class="comment"># 往有序集合key中删除元素</span></span><br><span class="line">ZREM key member [member...]                 </span><br><span class="line"><span class="comment"># 返回有序集合key中元素member的分值</span></span><br><span class="line">ZSCORE key member</span><br><span class="line"><span class="comment"># 返回有序集合key中元素个数</span></span><br><span class="line">ZCARD key </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为有序集合key中元素member的分值加上increment</span></span><br><span class="line">ZINCRBY key increment member </span><br><span class="line"></span><br><span class="line"><span class="comment"># 正序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"><span class="comment"># 倒序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span></span><br><span class="line">ZRANGEBYSCORE key <span class="built_in">min</span> <span class="built_in">max</span> [WITHSCORES] [LIMIT offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span></span><br><span class="line">ZRANGEBYLEX key <span class="built_in">min</span> <span class="built_in">max</span> [LIMIT offset count]</span><br><span class="line"><span class="comment"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span></span><br><span class="line">ZREVRANGEBYLEX key <span class="built_in">max</span> <span class="built_in">min</span> [LIMIT offset count]</span><br></pre></td></tr></table></figure>

<p>Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 并集计算(相同元素分值相加)，numberkeys一共多少个<span class="keyword">key</span>，WEIGHTS每个<span class="keyword">key</span>对应的分值乘积</span><br><span class="line">ZUNIONSTORE destkey numberkeys <span class="keyword">key</span> [<span class="keyword">key</span>...] </span><br><span class="line"># 交集计算(相同元素分值相加)，numberkeys一共多少个<span class="keyword">key</span>，WEIGHTS每个<span class="keyword">key</span>对应的分值乘积</span><br><span class="line">ZINTERSTORE destkey numberkeys <span class="keyword">key</span> [<span class="keyword">key</span>...]</span><br></pre></td></tr></table></figure>

<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><p>Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。</p>
<h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p>
<p>我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arcticle:1 文章获得了200个赞</span></span><br><span class="line">&gt; ZADD user:xiaolin:ranking 200 arcticle:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:2 文章获得了40个赞</span></span><br><span class="line">&gt; ZADD user:xiaolin:ranking 40 arcticle:2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:3 文章获得了100个赞</span></span><br><span class="line">&gt; ZADD user:xiaolin:ranking 100 arcticle:3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:4 文章获得了50个赞</span></span><br><span class="line">&gt; ZADD user:xiaolin:ranking 50 arcticle:4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:5 文章获得了150个赞</span></span><br><span class="line">&gt; ZADD user:xiaolin:ranking 150 arcticle:5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素member的分值加上increment）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> ZINCRBY <span class="keyword">user</span>:xiaolin:ranking <span class="number">1</span> arcticle:<span class="number">4</span></span><br><span class="line">&quot;51&quot;</span><br></pre></td></tr></table></figure>

<p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> ZSCORE <span class="keyword">user</span>:xiaolin:ranking arcticle:<span class="number">4</span></span><br><span class="line">&quot;50&quot;</span><br></pre></td></tr></table></figure>

<p>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WITHSCORES 表示把 score 也显示出来</span></span><br><span class="line">&gt; ZREVRANGE <span class="keyword">user</span>:xiaolin:ranking <span class="number">0</span> <span class="number">2</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;arcticle:1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;200&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;arcticle:5&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;150&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;arcticle:3&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure>

<p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> ZRANGEBYSCORE <span class="keyword">user</span>:xiaolin:ranking <span class="number">100</span> <span class="number">200</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) &quot;arcticle:3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;100&quot;</span><br><span class="line"><span class="number">3</span>) &quot;arcticle:5&quot;</span><br><span class="line"><span class="number">4</span>) &quot;150&quot;</span><br><span class="line"><span class="number">5</span>) &quot;arcticle:1&quot;</span><br><span class="line"><span class="number">6</span>) &quot;200&quot;</span><br></pre></td></tr></table></figure>

<h4 id="电话、姓名排序"><a href="#电话、姓名排序" class="headerlink" title="电话、姓名排序"></a>电话、姓名排序</h4><p>使用有序集合的 <code>ZRANGEBYLEX</code> 或 <code>ZREVRANGEBYLEX</code> 可以帮助我们实现电话号码或姓名的排序，我们以 <code>ZRANGEBYLEX</code> （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。</p>
<p><strong>注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</strong></p>
<p><em>1、电话排序</em></p>
<p>我们可以将电话号码存储到 SortSet 中，然后根据需要来获取号段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZADD phone 0 13100111100 0 13110114300 0 13132110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; ZADD phone 0 13200111100 0 13210414300 0 13252110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; ZADD phone 0 13300111100 0 13310414300 0 13352110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<p>获取所有号码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone - +</span><br><span class="line">1) <span class="string">&quot;13100111100&quot;</span></span><br><span class="line">2) <span class="string">&quot;13110114300&quot;</span></span><br><span class="line">3) <span class="string">&quot;13132110901&quot;</span></span><br><span class="line">4) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line">5) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line">6) <span class="string">&quot;13252110901&quot;</span></span><br><span class="line">7) <span class="string">&quot;13300111100&quot;</span></span><br><span class="line">8) <span class="string">&quot;13310414300&quot;</span></span><br><span class="line">9) <span class="string">&quot;13352110901&quot;</span></span><br></pre></td></tr></table></figure>

<p>获取 132 号段的号码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone [132 (133</span><br><span class="line">1) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line">2) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line">3) <span class="string">&quot;13252110901&quot;</span></span><br></pre></td></tr></table></figure>

<p>获取132、133号段的号码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone [132 (134</span><br><span class="line">1) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line">2) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line">3) <span class="string">&quot;13252110901&quot;</span></span><br><span class="line">4) <span class="string">&quot;13300111100&quot;</span></span><br><span class="line">5) <span class="string">&quot;13310414300&quot;</span></span><br><span class="line">6) <span class="string">&quot;13352110901&quot;</span></span><br></pre></td></tr></table></figure>

<p><em>2、姓名排序</em></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd names <span class="number">0</span> Toumas <span class="number">0</span> <span class="keyword">Jake </span><span class="number">0</span> <span class="keyword">Bluetuo </span><span class="number">0</span> Gaodeng <span class="number">0</span> Aimini <span class="number">0</span> Aidehua </span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>获取所有人的名字:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names - +</span><br><span class="line">1) <span class="string">&quot;Aidehua&quot;</span></span><br><span class="line">2) <span class="string">&quot;Aimini&quot;</span></span><br><span class="line">3) <span class="string">&quot;Bluetuo&quot;</span></span><br><span class="line">4) <span class="string">&quot;Gaodeng&quot;</span></span><br><span class="line">5) <span class="string">&quot;Jake&quot;</span></span><br><span class="line">6) <span class="string">&quot;Toumas&quot;</span></span><br></pre></td></tr></table></figure>

<p>获取名字中大写字母A开头的所有人：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names [A (B</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Aidehua&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Aimini&quot;</span></span><br></pre></td></tr></table></figure>

<p>获取名字中大写字母 C 到 Z 的所有人：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names [C [Z</span><br><span class="line">1) <span class="string">&quot;Gaodeng&quot;</span></span><br><span class="line">2) <span class="string">&quot;Jake&quot;</span></span><br><span class="line">3) <span class="string">&quot;Toumas&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-10-Stream"><a href="#2-10-Stream" class="headerlink" title="2.10 Stream"></a>2.10 Stream</h2><p> Redis 5.0 版本新增加的数据结构。</p>
<p>如下所示，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容：</p>
<p><img src="/images/img/blog/image-20220616175948239.png" alt="image-20220616175948239"></p>
<p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。</p>
<ul>
<li>Consumer Group ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。</li>
<li>last_delivered_id ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li>
<li>pending_ids ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。</li>
</ul>
<h3 id="Redis-Stream-相关命令"><a href="#Redis-Stream-相关命令" class="headerlink" title="Redis Stream 相关命令"></a>Redis Stream 相关命令</h3><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul>
<li><code>xadd</code> ：添加消息到末尾</li>
<li><code>xtrim</code> ：对流进行修剪，限制长度</li>
<li><code>xdel</code> ：删除消息</li>
<li><code>xlen</code> ：获取流包含的元素数量，即消息长度</li>
<li><code>xrange</code> ：获取消息列表，会自动过滤已经删除的消息</li>
<li><code>xrevrange</code> ：反向获取消息列表，ID 从大到小</li>
<li><code>xread</code> ：以阻塞或非阻塞方式获取消息列表</li>
</ul>
<h4 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h4><ul>
<li><code>xgroup create</code> ：创建消费者组</li>
<li><code>xreadgroup group</code> ：读取消费者组中的消息</li>
<li><code>xack</code> ：将消息标记为”已处理”</li>
<li><code>xgroup setid</code> ：为消费者组设置新的最后递送消息ID</li>
<li><code>xgroup delconsumer</code> ：删除消费者</li>
<li><code>xgroup destroy</code> ：删除消费者组</li>
<li><code>xpending</code> ：显示待处理消息的相关信息</li>
<li><code>xclaim</code> ：转移消息的归属权</li>
<li><code>xinfo</code> ：查看流和消费者组的相关信息</li>
<li><code>xinfo groups</code> ：打印消费者组的信息</li>
<li><code>xinfo stream</code> ：打印流信息</li>
</ul>
<p>帮助命令</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; help xadd</span><br><span class="line"></span><br><span class="line">  XADD key ID field value [field value ...]</span><br><span class="line">  summary: Appends a new entry to a stream</span><br><span class="line">  since: 5.0.0</span><br><span class="line">  group: stream</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; help xgroup</span><br><span class="line"></span><br><span class="line">  XGROUP [CREATE key groupname id-or-$] [SETID key groupname id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</span><br><span class="line">  summary: Create, destroy, and manage consumer groups.</span><br><span class="line">  since: 5.0.0</span><br><span class="line">  group: stream</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; xgroup help</span><br><span class="line"><span class="number">1</span>) XGROUP &lt;subcommand&gt; arg arg ... arg. Subcommands are:</span><br><span class="line"><span class="number">2</span>) CREATE      &lt;<span class="keyword">key</span>&gt; &lt;groupname&gt; &lt;id <span class="keyword">or</span> $&gt; [opt] -- Create a <span class="keyword">new</span> consumer group.</span><br><span class="line"><span class="number">3</span>)             <span class="keyword">option</span> MKSTREAM: create the empty stream <span class="keyword">if</span> it does <span class="keyword">not</span> exist.</span><br><span class="line"><span class="number">4</span>) SETID       &lt;<span class="keyword">key</span>&gt; &lt;groupname&gt; &lt;id <span class="keyword">or</span> $&gt;  -- Set the current group ID.</span><br><span class="line"><span class="number">5</span>) DESTROY     &lt;<span class="keyword">key</span>&gt; &lt;groupname&gt;            -- <span class="comment">Remove the specified group.</span></span><br><span class="line"><span class="number">6</span>) DELCONSUMER &lt;<span class="keyword">key</span>&gt; &lt;groupname&gt; &lt;consumer&gt; -- <span class="comment">Remove the specified consumer.</span></span><br><span class="line"><span class="number">7</span>) HELP                                     -- Prints this help.</span><br></pre></td></tr></table></figure>

<h3 id="Redis-Stream-命令解析"><a href="#Redis-Stream-命令解析" class="headerlink" title="Redis Stream 命令解析"></a>Redis Stream 命令解析</h3><h4 id="xadd-添加消息"><a href="#xadd-添加消息" class="headerlink" title="xadd 添加消息"></a>xadd 添加消息</h4><p>使用 <code>xadd</code> 向队列添加消息，如果指定的队列不存在，则创建一个队列。</p>
<p>语法格式： <code>XADD key ID field value [field value ...]</code> </p>
<ul>
<li>key：队列名称，如果不存在就创建</li>
<li>ID：消息 id，使用 * 表示由 redis 生成，可以自定义，但要自己保证唯一</li>
<li>field value：记录</li>
</ul>
<p>消息的全局唯一 ID 由两部分组成，第一部分“1619578295075”是数据插入时，以毫秒为单位计算的当前服务器时间，第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd mystream * name tingfeng</span><br><span class="line"><span class="string">&quot;1619578295075-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mystream * name balaili</span><br><span class="line"><span class="string">&quot;1619578304192-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mystream * f1 v1 f2 v2 f3 v3</span><br><span class="line"><span class="string">&quot;1619578307667-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xlen mystream</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; xrange mystream - +</span><br><span class="line">1) 1) <span class="string">&quot;1619578295075-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;tingfeng&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;1619578304192-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;balaili&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;1619578307667-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">      3) <span class="string">&quot;f2&quot;</span></span><br><span class="line">      4) <span class="string">&quot;v2&quot;</span></span><br><span class="line">      5) <span class="string">&quot;f3&quot;</span></span><br><span class="line">      6) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h4 id="xtrim-修剪流"><a href="#xtrim-修剪流" class="headerlink" title="xtrim 修剪流"></a>xtrim 修剪流</h4><p>使用 <code>xtrim</code> 对流进行范围修剪（取尾部数据），限制长度。</p>
<p>语法格式： <code>XTRIM key MAXLEN [~] count</code> </p>
<ul>
<li>key：队列名称</li>
<li>MAXLEN：长度</li>
<li>count：数量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xtrim mystream maxlen 2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; xrange mystream - +</span><br><span class="line">1) 1) <span class="string">&quot;1619578304192-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;balaili&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;1619578307667-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">      3) <span class="string">&quot;f2&quot;</span></span><br><span class="line">      4) <span class="string">&quot;v2&quot;</span></span><br><span class="line">      5) <span class="string">&quot;f3&quot;</span></span><br><span class="line">      6) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="xlen-流长度"><a href="#xlen-流长度" class="headerlink" title="xlen 流长度"></a>xlen 流长度</h4><p>使用 <code>xlen</code> 获取流包含的元素数量，即消息长度。</p>
<p>语法格式： <code>XLEN key</code> </p>
<ul>
<li>key：队列名称</li>
</ul>
<h4 id="xdel-删除消息"><a href="#xdel-删除消息" class="headerlink" title="xdel 删除消息"></a>xdel 删除消息</h4><p>使用 <code>xdel</code> 删除消息</p>
<p>语法格式： <code>XDEL key ID [ID ...]</code> </p>
<ul>
<li>key：队列名称</li>
<li>ID：消息 ID</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd mydemo * a 1</span><br><span class="line"><span class="string">&quot;1619579142062-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mydemo * b 2</span><br><span class="line"><span class="string">&quot;1619579145385-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mydemo * c 3 d 4 e 5</span><br><span class="line"><span class="string">&quot;1619579158816-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xlen mydemo</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; xdel mydemo 1619579145385-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; xrange mydemo - +</span><br><span class="line">1) 1) <span class="string">&quot;1619579142062-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;a&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;1619579158816-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;c&quot;</span></span><br><span class="line">      2) <span class="string">&quot;3&quot;</span></span><br><span class="line">      3) <span class="string">&quot;d&quot;</span></span><br><span class="line">      4) <span class="string">&quot;4&quot;</span></span><br><span class="line">      5) <span class="string">&quot;e&quot;</span></span><br><span class="line">      6) <span class="string">&quot;5&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del mydemo <span class="comment"># 删除key</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h4 id="xrange-消息列表"><a href="#xrange-消息列表" class="headerlink" title="xrange 消息列表"></a>xrange 消息列表</h4><p>使用 <code>xrange</code> 获取消息列表，会自动过滤已经删除的消息。</p>
<p>语法格式： <code>XRANGE key start end [COUNT count]</code> </p>
<ul>
<li>key：队列名</li>
<li>start：开始值， <code>-</code> 表示最小值</li>
<li>end：结束值， <code>+</code> 表示最大值</li>
<li>count：数量（取头部数据）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd mydemo * name aaa</span><br><span class="line"><span class="string">&quot;1619579326631-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mydemo * name bbb</span><br><span class="line"><span class="string">&quot;1619579328639-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mydemo * name ccc</span><br><span class="line"><span class="string">&quot;1619579330732-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mydemo * name ddd</span><br><span class="line"><span class="string">&quot;1619579333019-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mydemo * name eee</span><br><span class="line"><span class="string">&quot;1619579335736-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xlen mydemo</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; xrange mydemo - + count 2</span><br><span class="line">1) 1) <span class="string">&quot;1619579326631-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;aaa&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;1619579328639-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del mydemo <span class="comment"># 删除key</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h4 id="xrevrange-消息列表"><a href="#xrevrange-消息列表" class="headerlink" title="xrevrange 消息列表"></a>xrevrange 消息列表</h4><p>使用 <code>xrevrange</code> 获取消息列表，会自动过滤已经删除的消息。<br>语法格式： <code>XREVRANGE key end start [COUNT count]</code> </p>
<ul>
<li>key：队列名</li>
<li>end：结束值，<code>+</code> 表示最大值</li>
<li>start：开始值，<code>-</code> 表示最小值</li>
<li>count：数量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd mydemo * name aaa</span><br><span class="line"><span class="string">&quot;1619579822470-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mydemo * name bbb</span><br><span class="line"><span class="string">&quot;1619579825203-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mydemo * name ccc</span><br><span class="line"><span class="string">&quot;1619579827369-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xlen mydemo</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; xrevrange mydemo + -</span><br><span class="line">1) 1) <span class="string">&quot;1619579827369-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ccc&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;1619579825203-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;bbb&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;1619579822470-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;aaa&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xrevrange mydemo + - count 1</span><br><span class="line">1) 1) <span class="string">&quot;1619579827369-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ccc&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="xread-消息列表"><a href="#xread-消息列表" class="headerlink" title="xread 消息列表"></a>xread 消息列表</h4><p>使用 <code>xread</code> 以阻塞或非阻塞方式获取消息列表。</p>
<p>语法格式： <code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</code> </p>
<ul>
<li><code>count</code> ：数量</li>
<li><code>milliseconds</code> / <code>block</code> ：阻塞毫秒数，没有设置就是非阻塞模式，取到一个结果就退出。</li>
<li><code>key</code> ：队列名</li>
<li><code>id</code> ：消息 ID</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建两个流</span></span><br><span class="line">127.0.0.1:6379&gt; xadd demo1 * name aaa</span><br><span class="line"><span class="string">&quot;1619580212875-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd demo1 * name bbb</span><br><span class="line"><span class="string">&quot;1619580215254-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd demo2 * name ccc</span><br><span class="line"><span class="string">&quot;1619580226876-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd demo2 * name ddd</span><br><span class="line"><span class="string">&quot;1619580230966-0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取所有</span></span><br><span class="line"><span class="comment"># 0-0 从头消费</span></span><br><span class="line">127.0.0.1:6379&gt; xread streams demo1 0-0</span><br><span class="line">1) 1) <span class="string">&quot;demo1&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1619580212875-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;aaa&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;1619580215254-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取1个头部消息</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 1 streams demo1 0-0</span><br><span class="line">1) 1) <span class="string">&quot;demo1&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1619580212875-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取两个key的头部消息</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 1 streams demo1 demo2 0-0 0-0</span><br><span class="line">1) 1) <span class="string">&quot;demo1&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1619580212875-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;aaa&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;demo2&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1619580226876-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;ccc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞30秒监听demo3消息，有一个结果就退出</span></span><br><span class="line"><span class="comment"># $ 表示最新消息</span></span><br><span class="line">127.0.0.1:6379&gt; xread block 30000 streams demo3 $</span><br><span class="line">1) 1) <span class="string">&quot;demo3&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1619580596131-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;ttt&quot;</span></span><br><span class="line">(1.84s)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>命令最后的“ <code>$</code> ”符号表示读取最新的消息，同时，我们设置了 block 30000 的配置项，单位是毫秒，表明在读取最新消息时，如果没有消息到来，将阻塞30000 毫秒（即 30 秒），然后再返回。</p>
<h4 id="xgroup-create-创建消费者组"><a href="#xgroup-create-创建消费者组" class="headerlink" title="xgroup create 创建消费者组"></a>xgroup create 创建消费者组</h4><p>Streams 本身可以使用 xgroup 创建消费组，创建消费组之后，Streams 可以使用 xreadgroup 命令让消费组内的消费者读取消息。</p>
<p>使用 <code>xgroup create</code> 创建消费者组。</p>
<p>语法格式： <code>XGROUP [CREATE key groupname id-or-$] [SETID key groupname id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</code> </p>
<ul>
<li>key：队列名称，如果不存在就创建</li>
<li>groupname：组名。</li>
<li>$：从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从头开始消费</span></span><br><span class="line">xgroup create mystream consumer-group-name 0-0  </span><br><span class="line"></span><br><span class="line"><span class="comment">#从尾部开始消费</span></span><br><span class="line">xgroup create mystream consumer-group-name $</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd mydemo * name aaa</span><br><span class="line"><span class="string">&quot;1619581865830-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mydemo * name bbb</span><br><span class="line"><span class="string">&quot;1619581868367-0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xadd mydemo * name ccc</span><br><span class="line"><span class="string">&quot;1619581870373-0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 group1 消费组，消费 mydemo 队列消息</span></span><br><span class="line">127.0.0.1:6379&gt; xgroup create mydemo group1 0</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让 group1 消费组里的消费者 consumer1 从 mydemo 中读取所有消息</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 consumer1 streams mydemo &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mydemo&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1619581865830-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;aaa&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;1619581868367-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;bbb&quot;</span></span><br><span class="line">      3) 1) <span class="string">&quot;1619581870373-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;ccc&quot;</span></span><br></pre></td></tr></table></figure>

<p>命令最后的参数“ <code>&gt;</code> ”，表示从第一条尚未被消费的消息开始读取。因为在 consumer1 读取消息前，group1 中没有其他消费者读取过消息，所以 consumer1 就得到 mydemo 消息队列中的所有消息了（消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了）。</p>
<h4 id="xreadgroup-group-读取消费者组消息"><a href="#xreadgroup-group-读取消费者组消息" class="headerlink" title="xreadgroup group 读取消费者组消息"></a>xreadgroup group 读取消费者组消息</h4><p>使用 <code>xreadgroup group</code> 读取消费组中的消息。</p>
<p>语法格式： <code>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code> </p>
<ul>
<li>group：消费组名</li>
<li>consumer：消费者名</li>
<li>count：读取数量</li>
<li>milliseconds / block：阻塞毫秒数</li>
<li>key：队列名</li>
<li>ID：消息 ID</li>
</ul>
<p>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。</p>
<p>例如，我们执行下列命令，让 group2 中的 consumer1、2、3 各自读取一条消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599203861727-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;5&quot;</span></span><br><span class="line"></span><br><span class="line">XREADGROUP group group2 consumer2 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599274912765-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line">XREADGROUP group group2 consumer3 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599274925823-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p>为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 <code>xack</code> 命令通知 Streams“消息已经处理完成”。如果消费者没有成功处理消息，它就不会给 Streams 发送 <code>xack</code> 命令，消息仍然会留存。此时，消费者可以在重启后，用 <code>xpending</code> 命令查看已读取、但尚未确认处理完成的消息。</p>
<h4 id="xpending-待处理消息信息"><a href="#xpending-待处理消息信息" class="headerlink" title="xpending 待处理消息信息"></a>xpending 待处理消息信息</h4><p><code>xpending</code> 命令是检查待处理消息列表的接口，用于观察和了解消费者组正在发生的事情：哪些客户端是活跃的，哪些消息在等待消费，或者查看是否有空闲的消息。</p>
<p>此命令与 <code>xclaim</code> 一起使用，用于实现长时间故障的消费者的恢复。</p>
<p>语法格式： <code>xpendign key groupName [start end count] [consumerName]</code> </p>
<p>xpending是一个只读的命令，会输出指定group中所有处于pending message中的消息总个数、开始ID、结束ID、每个consumer中pending message中消息的个数。可以通过指定开始结束id和consumerName来获取更加详细的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xpending mydemo group1</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) <span class="string">&quot;1619581865830-0&quot;</span>  <span class="comment"># 消息开始ID</span></span><br><span class="line">3) <span class="string">&quot;1619581870373-0&quot;</span>  <span class="comment"># 消息结束ID</span></span><br><span class="line">4) 1) 1) <span class="string">&quot;consumer1&quot;</span>  <span class="comment"># 消费者</span></span><br><span class="line">      2) <span class="string">&quot;3&quot;</span>                  <span class="comment"># 消费数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制消息数量</span></span><br><span class="line">127.0.0.1:6379&gt; xpending mydemo group1 - + 3</span><br><span class="line">1) 1) <span class="string">&quot;1619581865830-0&quot;</span>       <span class="comment"># 消息id</span></span><br><span class="line">   2) <span class="string">&quot;consumer1&quot;</span>                 <span class="comment"># 消费者</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 12258065    <span class="comment"># 自上次将此消息传递给该消费者以来，经过的毫秒数</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 1                   <span class="comment"># 读取的次数</span></span><br><span class="line">2) 1) <span class="string">&quot;1619581868367-0&quot;</span></span><br><span class="line">   2) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 12258065</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) 1) <span class="string">&quot;1619581870373-0&quot;</span></span><br><span class="line">   2) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 12258065</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制指定消费者消息数量</span></span><br><span class="line">127.0.0.1:6379&gt; xpending mydemo group1 - + 2 consumer1</span><br><span class="line">1) 1) <span class="string">&quot;1619581865830-0&quot;</span></span><br><span class="line">   2) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 12352110</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) 1) <span class="string">&quot;1619581868367-0&quot;</span></span><br><span class="line">   2) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 12352110</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h4 id="11、xack-消息标记"><a href="#11、xack-消息标记" class="headerlink" title="11、xack 消息标记"></a>11、xack 消息标记</h4><p>消息标记确认</p>
<p>使用 <code>xack</code> 命令通知 Streams，然后这条消息就会被删除。当我们再使用 <code>xpending</code> 命令查看时，就可以看到，consumer1 已经没有已读取、但尚未确认处理的消息了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让 group1 消费组里的消费者 consumer1 从 mydemo 中读取所有消息</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 consumer1 streams mydemo &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mydemo&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1619581865830-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;aaa&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;1619581868367-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;bbb&quot;</span></span><br><span class="line">      3) 1) <span class="string">&quot;1619581870373-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;ccc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ack 确认</span></span><br><span class="line">127.0.0.1:6379&gt; xack mydemo group1 1619581868367-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; xack mydemo group1 1619581865830-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; xpending mydemo group1</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) <span class="string">&quot;1619581870373-0&quot;</span></span><br><span class="line">3) <span class="string">&quot;1619581870373-0&quot;</span></span><br><span class="line">4) 1) 1) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="xgroup-setid-消费者组设置新的最后递送消息ID"><a href="#xgroup-setid-消费者组设置新的最后递送消息ID" class="headerlink" title="xgroup setid 消费者组设置新的最后递送消息ID"></a>xgroup setid 消费者组设置新的最后递送消息ID</h4><p>使用 <code>setid</code> 子命令设置要传递的下一条消息。 通常情况，在消费者创建时设置下一个ID，作为 <code>xgroup create</code> 最后一个参数。 但是使用这种形式，可以在以后修改下一个ID，而无需再次删除和创建使用者组。</p>
<p>例如，如果你希望消费者组中的消费者重新处理流中的所有消息，你可能希望将其下一个ID设置为0。</p>
<h4 id="xgroup-delconsumer-删除消费者"><a href="#xgroup-delconsumer-删除消费者" class="headerlink" title="xgroup delconsumer 删除消费者"></a>xgroup delconsumer 删除消费者</h4><p>从消费者组中移除给定的消费者，使用以下命令格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup delconsumer mydemo group1 consumer1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h4 id="xgroup-destroy-删除消费者组"><a href="#xgroup-destroy-删除消费者组" class="headerlink" title="xgroup destroy 删除消费者组"></a>xgroup destroy 删除消费者组</h4><p>即使存在活动的消费者和待处理消息，消费者组也将被销毁，因此请确保仅在真正需要时才调用此命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup destroy mydemo group1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h4 id="xclaim-转移消息归属权"><a href="#xclaim-转移消息归属权" class="headerlink" title="xclaim 转移消息归属权"></a>xclaim 转移消息归属权</h4><p>语法格式： <code>xclaim key groupName comsumer minIdleTime id [id ...] [IDLE ms] [TIME msUnixTime] [RETRYCOUNT count] [force] [justid]</code> </p>
<h4 id="xinfo-流和消费者组信息"><a href="#xinfo-流和消费者组信息" class="headerlink" title="xinfo 流和消费者组信息"></a>xinfo 流和消费者组信息</h4><p>检索关于流和关联的消费者组的不同的信息。</p>
<p>语法格式： <code>XINFO STREAM &lt;key&gt;</code> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xinfo stream mydemo</span><br><span class="line"> 1) <span class="string">&quot;length&quot;</span>  </span><br><span class="line">2) (<span class="built_in">integer</span>) 3          <span class="comment"># 流元素的数量</span></span><br><span class="line"> 3) <span class="string">&quot;radix-tree-keys&quot;</span></span><br><span class="line"> 4) (<span class="built_in">integer</span>) 1</span><br><span class="line"> 5) <span class="string">&quot;radix-tree-nodes&quot;</span></span><br><span class="line"> 6) (<span class="built_in">integer</span>) 2</span><br><span class="line"> 7) <span class="string">&quot;last-generated-id&quot;</span></span><br><span class="line">8) <span class="string">&quot;1619581870373-0&quot;</span>  <span class="comment"># 最后消息ID</span></span><br><span class="line"> 9) <span class="string">&quot;groups&quot;</span></span><br><span class="line">10) (<span class="built_in">integer</span>) 1             <span class="comment"># 消费者组数量</span></span><br><span class="line">11) <span class="string">&quot;first-entry&quot;</span>             <span class="comment"># 第一个消息</span></span><br><span class="line">12) 1) <span class="string">&quot;1619581865830-0&quot;</span></span><br><span class="line">    2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">       2) <span class="string">&quot;aaa&quot;</span></span><br><span class="line">13) <span class="string">&quot;last-entry&quot;</span>              <span class="comment"># 最后一个消息</span></span><br><span class="line">14) 1) <span class="string">&quot;1619581870373-0&quot;</span></span><br><span class="line">    2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">       2) <span class="string">&quot;ccc&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="xinfo-groups-消费者组的信息"><a href="#xinfo-groups-消费者组的信息" class="headerlink" title="xinfo groups 消费者组的信息"></a>xinfo groups 消费者组的信息</h4><p>只获得与流关联的所有消费者组的输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xinfo groups mydemo</span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;group1&quot;</span></span><br><span class="line">   3) <span class="string">&quot;consumers&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br><span class="line">   5) <span class="string">&quot;pending&quot;</span></span><br><span class="line">   6) (<span class="built_in">integer</span>) 3</span><br><span class="line">   7) <span class="string">&quot;last-delivered-id&quot;</span></span><br><span class="line">   8) <span class="string">&quot;1619581870373-0&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="xinfo-stream-流信息"><a href="#xinfo-stream-流信息" class="headerlink" title="xinfo stream 流信息"></a>xinfo stream 流信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xinfo consumers mydemo group1</span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">   3) <span class="string">&quot;pending&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 3</span><br><span class="line">   5) <span class="string">&quot;idle&quot;</span></span><br><span class="line">   6) (<span class="built_in">integer</span>) 417812</span><br></pre></td></tr></table></figure>

<h3 id="2-11总结"><a href="#2-11总结" class="headerlink" title="2.11总结"></a>2.11总结</h3><p>Redis 五种数据类型的应用场景：</p>
<ul>
<li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享session信息等。</li>
<li>List 类型的应用场景：消息队列（有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li>
<li>Hash 类型：缓存对象、购物车等。</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>
</ul>
<p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p>
<ul>
<li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li>
<li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li>
<li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li>
<li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li>
</ul>
<h1 id="3-通用指令"><a href="#3-通用指令" class="headerlink" title="3.通用指令"></a>3.通用指令</h1><h2 id="3-1key通用指令"><a href="#3-1key通用指令" class="headerlink" title="3.1key通用指令"></a>3.1key通用指令</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">del</span> <span class="selector-tag">key</span>      删除指定<span class="selector-tag">key</span></span><br><span class="line"><span class="selector-tag">exists</span> <span class="selector-tag">key</span>   获取<span class="selector-tag">key</span>是否存在</span><br><span class="line"><span class="selector-tag">type</span> <span class="selector-tag">key</span>     获取<span class="selector-tag">key</span>的类型</span><br><span class="line"></span><br><span class="line">扩展操作（时效性控制）</span><br><span class="line">为指定<span class="selector-tag">key</span>设置有效期</span><br><span class="line"><span class="selector-tag">expire</span> <span class="selector-tag">key</span> <span class="selector-tag">seconds</span></span><br><span class="line"><span class="selector-tag">pexpire</span> <span class="selector-tag">key</span> <span class="selector-tag">milliseconds</span></span><br><span class="line"><span class="selector-tag">expireat</span> <span class="selector-tag">key</span> <span class="selector-tag">timestamp</span></span><br><span class="line"><span class="selector-tag">pexpireat</span> <span class="selector-tag">key</span> <span class="selector-tag">milliseconds-timestamp</span></span><br><span class="line"></span><br><span class="line">获取<span class="selector-tag">key</span>的有效时间</span><br><span class="line"><span class="selector-tag">ttl</span> <span class="selector-tag">key</span></span><br><span class="line"><span class="selector-tag">pttl</span> <span class="selector-tag">key</span></span><br><span class="line"></span><br><span class="line">切换<span class="selector-tag">key</span>从时效性转换为永久性</span><br><span class="line"><span class="selector-tag">persist</span> <span class="selector-tag">key</span></span><br><span class="line"></span><br><span class="line">查询模式</span><br><span class="line"><span class="selector-tag">keys</span> <span class="selector-tag">pattern</span></span><br><span class="line">查询模式规则：* 匹配任意数量的任意符号 ? 配合一个任意符号 <span class="selector-attr">[]</span> 匹配一个指定符号</span><br><span class="line"></span><br><span class="line">其他操作</span><br><span class="line">为<span class="selector-tag">key</span>改名</span><br><span class="line"><span class="selector-tag">rename</span> <span class="selector-tag">key</span> <span class="selector-tag">newkey</span></span><br><span class="line"><span class="selector-tag">renamenx</span> <span class="selector-tag">key</span> <span class="selector-tag">newkey</span></span><br><span class="line"></span><br><span class="line">对所有<span class="selector-tag">key</span>排序</span><br><span class="line"><span class="selector-tag">sort</span></span><br><span class="line"></span><br><span class="line">其他<span class="selector-tag">key</span>通用操作</span><br><span class="line"><span class="selector-tag">help</span> @<span class="selector-tag">generic</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2数据库通用指令"><a href="#3-2数据库通用指令" class="headerlink" title="3.2数据库通用指令"></a>3.2数据库通用指令</h2><p>为了防止redis使用过程中，数据量急剧增加产生重复和冲突，redis为每个服务创建16个数据库，编号从0到15且数据库之间的数据相互独立。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">select</span> <span class="selector-tag">index</span>  切换数据库</span><br><span class="line"><span class="selector-tag">quit</span></span><br><span class="line"><span class="selector-tag">ping</span></span><br><span class="line"><span class="selector-tag">echo</span> <span class="selector-tag">message</span>   其他操作</span><br><span class="line"><span class="selector-tag">move</span> <span class="selector-tag">key</span> <span class="selector-tag">db</span>    数据移动</span><br><span class="line"><span class="selector-tag">dbsize</span></span><br><span class="line"><span class="selector-tag">flushdb</span></span><br><span class="line"><span class="selector-tag">flushall</span>       数据清除</span><br></pre></td></tr></table></figure>

<h1 id="4-redis持久化"><a href="#4-redis持久化" class="headerlink" title="4.redis持久化"></a>4.redis持久化</h1><p>持久化：利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p>
<p>redis持久化技术有RDB持久化和AOF持久化</p>
<h2 id="4-1RDB持久化"><a href="#4-1RDB持久化" class="headerlink" title="4.1RDB持久化"></a>4.1RDB持久化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">RDB启动方式——save指令</span><br><span class="line"></span><br><span class="line">save   手动执行一次保存操作</span><br><span class="line">save 900 1</span><br><span class="line">说明： 当 900 秒内有至少有 1 个键被改动时，自动进行数据集保存操作</span><br><span class="line">save 300 10</span><br><span class="line">说明： 当 300 秒内有至少有 10 个键被改动时，自动进行数据集保存操作</span><br><span class="line">save 60 10000</span><br><span class="line">说明： 当 60 秒内有至少有 10000 个键被改动时，自动进行数据集保存操作</span><br><span class="line"></span><br><span class="line">save指令相关配置</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">说明：后台存储过程中如果出现错误现象，是否停止保存操作</span><br><span class="line">经验：通常默认为开启状态</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">说明：设置本地数据库文件名，默认值为 dump.rdb</span><br><span class="line">经验：通常设置为dump-端口号.rdb</span><br><span class="line">dir /var/lib/redis</span><br><span class="line">说明：设置存储.rdb文件的路径</span><br><span class="line">经验：通常设置成存储空间较大的目录中，目录名称data</span><br><span class="line">rdbcompression yes</span><br><span class="line">说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩</span><br><span class="line">经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</span><br><span class="line">rdbchecksum yes</span><br><span class="line">说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行</span><br><span class="line">经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。</strong>（单线程任务执行序列）</p>
<p>bgsave指令工作原理</p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/20200502185440745.png" alt="在这里插入图片描述"></p>
<p>注意： bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RDB自动启动--save</span><br><span class="line">save second changes    满足限定时间范围内key的变化数量达到指定数量即进行持久化</span><br><span class="line">second：监控时间范围     changes：监控key的变化量</span><br><span class="line">在conf文件中进行配置</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RDB特殊启动方式--全量复制</span><br><span class="line">debug reload       服务器运行过程中重启</span><br><span class="line">shutdown save      关闭服务器时指定保存数据</span><br></pre></td></tr></table></figure>

<p><strong>注意：默认情况下执行shutdown命令时，自动执行 bgsave(如果没有开启AOF持久化功能)</strong></p>
<p>RDB优点：</p>
<ul>
<li> RDB是一个紧凑压缩的二进制文件，存储效率较高</li>
<li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li>
<li>RDB恢复数据的速度要比AOF快很多</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li>
</ul>
<p>RDB缺点：</p>
<ul>
<li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li>
<li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li>
<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</li>
</ul>
<h2 id="4-2AOP持久化"><a href="#4-2AOP持久化" class="headerlink" title="4.2AOP持久化"></a>4.2AOP持久化</h2><p>AOF持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令 达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程。（相比RDB，解决了数据持久化的实时性）。</p>
<p><strong>AOF写数据的三种策略：always(每次，数据零误差，性能较低)，everysec(每秒，准确率较高，性能较高，推荐使用也是默认配置)，no(系统控制，由操作系统控制同步到AOF文件的周期，不可控)。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">配置:	appendonly yes|no</span><br><span class="line">作用:	是否开启AOF持久化功能，默认为不开启状态</span><br><span class="line">配置AOF写数据的三种策略: appendfsync always|everysec|no</span><br><span class="line"></span><br><span class="line"># appendfsync always   &#x2F;&#x2F; 每收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用</span><br><span class="line"></span><br><span class="line">appendfsync everysec   &#x2F;&#x2F; 每秒强制写入磁盘一次，性能和持久化方面做了折中，只会丢失一秒钟的数据，推荐</span><br><span class="line">    </span><br><span class="line"># appendfsync no       &#x2F;&#x2F; 从不进行写入，更不安全的选择</span><br><span class="line"></span><br><span class="line">配置:	appendfilename filename</span><br><span class="line">作用:	AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aof</span><br><span class="line"></span><br><span class="line">配置:	dir</span><br><span class="line">作用:	AOF持久化文件保存路径，与RDB持久化文件保持一致即可</span><br></pre></td></tr></table></figure>



<p>AOF重写：随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。（简单说就是将对同一个数据的若干个条命令执行结 果转化成最终结果数据对应的指令进行记录）</p>
<p>AOF重写规则：</p>
<ul>
<li> 进程内已超时的数据不再写入文件</li>
<li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令</li>
<li>对同一数据的多条写命令合并为一条命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AOF重写方式</span><br><span class="line">手动重写:	bgrewriteaof</span><br><span class="line">自动重写:	auto-aof-rewrite-min-size size</span><br><span class="line">           auto-aof-rewrite-percentage percentage</span><br><span class="line">           </span><br><span class="line">AOF自动重写方式</span><br><span class="line">自动重写触发条件设置</span><br><span class="line">auto-aof-rewrite-min-size size</span><br><span class="line">auto-aof-rewrite-percentage percent</span><br><span class="line"></span><br><span class="line">自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</span><br><span class="line">aof_current_size</span><br><span class="line">aof_base_size</span><br><span class="line"></span><br><span class="line">自动重写触发条件</span><br><span class="line">aof_current_size &gt; auto-aof-rewrite-min-size</span><br><span class="line">aof_current_size - aof_base_size &gt;&#x3D; auto-aof-rewrite-percentage * aof_base_size</span><br></pre></td></tr></table></figure>

<h2 id="4-3混合持久化"><a href="#4-3混合持久化" class="headerlink" title="4.3混合持久化"></a>4.3混合持久化</h2><p>　　重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。集成了 RDB 和 AOF 的优点</p>
<p>　　通过如下配置可以开启混合持久化(<strong>必须先开启aof</strong>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof‐use‐rdb‐preamble yes  &#x2F;&#x2F; 开启混合持久化，必须先开启AOF</span><br></pre></td></tr></table></figure>

<p>　　如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的AOF 全量文件重放，因此重启效率大幅得到提升。</p>
<p>　　混合持久化AOF文件结构如下：</p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/image-20220617093438692.png" alt="image-20220617093438692"></p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/1087394-20220301161931027-1274941271.png" alt="img"></p>
<p> <strong>Redis数据备份策略：</strong></p>
<p>　　1. 写crontab定时调度脚本，每小时都copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48小时的备份<br>　　2. 每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份<br>　　3. 每次copy备份的时候，都把太旧的备份给删了<br>　　4. 每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏</p>
<h1 id="5-redis事务"><a href="#5-redis事务" class="headerlink" title="5.redis事务"></a>5.redis事务</h1><h2 id="5-1事务基本操作"><a href="#5-1事务基本操作" class="headerlink" title="5.1事务基本操作"></a>5.1事务基本操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务的基本操作</span><br><span class="line">multi    开启事务（开始位置）</span><br><span class="line">exec     执行事务（结束位置）</span><br><span class="line">discard  取消事务（开始与结束之间）</span><br></pre></td></tr></table></figure>

<p>注意：①如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。②已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</p>
<h2 id="5-2锁"><a href="#5-2锁" class="headerlink" title="5.2锁"></a>5.2锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch key1 [key2……]    对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</span><br><span class="line">unwatch                取消对所有 key 的监视</span><br></pre></td></tr></table></figure>

<h2 id="5-3基于特定事务执行——分布式锁"><a href="#5-3基于特定事务执行——分布式锁" class="headerlink" title="5.3基于特定事务执行——分布式锁"></a>5.3基于特定事务执行——分布式锁</h2><p>例如超卖场景：天猫双11热卖过程中，对已经售罄的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解决方案</span><br><span class="line">setnx lock-key value   使用 setnx 设置一个公共锁</span><br><span class="line">利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</span><br><span class="line">对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</span><br><span class="line">对于返回设置失败的，不具有控制权，排队或等待</span><br><span class="line">操作完毕通过del操作释放锁</span><br></pre></td></tr></table></figure>

<p>特定事务2场景：依赖分布式锁的机制，某个用户操作时对应客户端宕机，且此时已经获取到锁。如何解决？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 expire 为锁key添加时间限定，到时不释放，放弃锁</span><br><span class="line">expire lock-key second</span><br><span class="line">pexpire lock-key milliseconds</span><br></pre></td></tr></table></figure>

<h1 id="6-redis删除策略"><a href="#6-redis删除策略" class="headerlink" title="6.redis删除策略"></a>6.redis删除策略</h1><h2 id="6-1数据删除策略"><a href="#6-1数据删除策略" class="headerlink" title="6.1数据删除策略"></a>6.1数据删除策略</h2><p>数据删除策略的目标：在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或 内存泄露。</p>
<h2 id="1-定时删除"><a href="#1-定时删除" class="headerlink" title="1.定时删除"></a>1.定时删除</h2><ul>
<li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</li>
<li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</li>
<li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li>
<li>总结：用处理器性能换取存储空间（拿时间换空间）</li>
</ul>
<h2 id="2-惰性删除"><a href="#2-惰性删除" class="headerlink" title="2.惰性删除"></a>2.惰性删除</h2><ul>
<li>数据到达过期时间，不做处理。等下次访问该数据时：1. 如果未过期，返回数据。2. 发现已过期，删除，返回不存在。</li>
<li>优点：节约CPU性能，发现必须删除的时候才删除</li>
<li>缺点：内存压力很大，出现长期占用内存的数据</li>
<li>总结：用存储空间换取处理器性能（拿空间换时间）</li>
</ul>
<h2 id="3-定期删除（随机抽查，重点抽查）"><a href="#3-定期删除（随机抽查，重点抽查）" class="headerlink" title="3.定期删除（随机抽查，重点抽查）"></a>3.定期删除（随机抽查，重点抽查）</h2><p>定时删除和惰性删除的折中方案</p>
<ul>
<li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p>
</li>
<li><p>每秒钟执行server.hz次serverCron()  –&gt;  databasesCron()  –&gt;  activeExpireCycle()</p>
</li>
<li><p>activeExpireCycle()对每个expires[*]逐一进行检测，每次执行250ms/server.hz</p>
</li>
<li><p>对某个expires[*]检测时，随机挑选W个key检测：</p>
<ul>
<li> 如果key超时，删除key</li>
<li>如果一轮中删除的key的数量&gt;W*25%，循环该过程</li>
<li>如果一轮中删除的key的数量≤W<em>25%，检查下一个expires[</em>]，0-15循环</li>
<li>W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</li>
</ul>
</li>
<li><p> 参数current_db用于记录activeExpireCycle() 进入哪个expires[*] 执行</p>
</li>
<li><p>如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行                               </p>
</li>
</ul>
<h2 id="6-2逐出算法"><a href="#6-2逐出算法" class="headerlink" title="6.2逐出算法"></a>6.2逐出算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">逐出算法的相关配置</span><br><span class="line">maxmemory      最大可使用内存（生产环境一般设置为50%）</span><br><span class="line">maxmemory-samples    每次选取待删除数据的个数（选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。）</span><br><span class="line">maxmemory-policy     删除策略（达到最大内存后的，对被挑选出来的数据进行删除的策略）</span><br></pre></td></tr></table></figure>

<p>逐出算法：</p>
<ul>
<li><p>检测易失数据（可能会过期的数据集server.db[i].expires ）</p>
<ul>
<li>volatile-lru：挑选最近最少使用的数据淘汰</li>
<li>volatile-lfu：挑选最近使用次数最少的数据淘汰</li>
<li>volatile-ttl：挑选将要过期的数据淘汰</li>
<li>volatile-random：任意选择数据淘汰</li>
</ul>
</li>
<li><p> 检测全库数据（所有数据集server.db[i].dict ）</p>
</li>
<li><p>allkeys-lru：挑选最近最少使用的数据淘汰</p>
</li>
<li><p>allkeys-lfu：挑选最近使用次数最少的数据淘汰</p>
</li>
<li><p> allkeys-random：任意选择数据淘汰</p>
</li>
<li><p>放弃数据驱逐</p>
<ul>
<li>no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</li>
</ul>
</li>
</ul>
<h1 id="7-redis核心配置"><a href="#7-redis核心配置" class="headerlink" title="7.redis核心配置"></a>7.redis核心配置</h1><p>服务端设定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes|no   设置服务器以守护进程的方式运行</span><br><span class="line">bind 127.0.0.1     绑定主机地址</span><br><span class="line">port 6379          设置服务器端口号</span><br><span class="line">databases 16       设置数据库数量</span><br><span class="line"></span><br><span class="line">日志配置</span><br><span class="line">loglevel debug|verbose|notice|warning    设置服务器以指定日志记录级别</span><br><span class="line">logfile 端口号.log    日志记录文件名</span><br><span class="line"></span><br><span class="line">多服务器快捷配置</span><br><span class="line">include &#x2F;path&#x2F;server-端口号.conf   导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护</span><br></pre></td></tr></table></figure>

<p>注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度。</p>
<p>客户端配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxclients 0       设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接</span><br><span class="line">timeout 300        客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为 0</span><br></pre></td></tr></table></figure>

<h1 id="8-高级数据类型"><a href="#8-高级数据类型" class="headerlink" title="8.高级数据类型"></a>8.高级数据类型</h1><h2 id="8-1Bitmaps"><a href="#8-1Bitmaps" class="headerlink" title="8.1Bitmaps"></a>8.1Bitmaps</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">基础操作</span><br><span class="line">getbit key offset        获取指定key对应偏移量上的bit值</span><br><span class="line">setbit key offset value  设置指定key对应偏移量上的bit值，value只能是1或0</span><br><span class="line"></span><br><span class="line">扩展操作</span><br><span class="line">bitop op destKey key1 [key2...]   对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中</span><br><span class="line">bitcount key [start end]          统计指定key中1的数量</span><br></pre></td></tr></table></figure>

<p>业务场景：应用于信息状态统计</p>
<p>电影网站</p>
<ul>
<li>统计每天某一部电影是否被点播</li>
<li>统计每天有多少部电影被点播</li>
<li>统计每周/月/年有多少部电影被点播</li>
<li>统计年度哪部电影没有被点播</li>
</ul>
<h2 id="8-2HyperLogLog"><a href="#8-2HyperLogLog" class="headerlink" title="8.2HyperLogLog"></a>8.2HyperLogLog</h2><p>基数： 基数是数据集去重后元素个数</p>
<p>HyperLogLog 是用来做<strong>基数</strong>统计的，运用了LogLog的算法</p>
<p>eg：{1, 3, 5, 7, 5, 7, 8}    基数集： {1, 3, 5 ,7, 8}    基数：5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element ...]             添加数据</span><br><span class="line">pfcount key [key ...]                       统计数据</span><br><span class="line">pfmerge destkey sourcekey [sourcekey...]    合并数据</span><br></pre></td></tr></table></figure>

<p>业务场景：应用于独立信息的统计</p>
<p>注意：</p>
<ul>
<li> 用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据</li>
<li>核心是基数估算算法，最终数值存在一定误差</li>
<li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li>
<li>消耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数</li>
<li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大</li>
<li>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少</li>
</ul>
<h2 id="8-3GEO"><a href="#8-3GEO" class="headerlink" title="8.3GEO"></a>8.3GEO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">基本操作</span><br><span class="line">geoadd key longitude latitude member [longitude latitude member ...]    添加坐标点</span><br><span class="line">geopos key member [member ...]                                          获取坐标点</span><br><span class="line">geodist key member1 member2 [unit]                                      计算坐标点距离</span><br><span class="line"></span><br><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]  添加坐标点</span><br><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]      获取坐标点</span><br><span class="line">geohash key member [member ...]     计算经纬度</span><br></pre></td></tr></table></figure>

<h1 id="9-主从复制"><a href="#9-主从复制" class="headerlink" title="9.主从复制"></a>9.主从复制</h1><p>目的：为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续 提供服务，<strong>实现Redis的高可用</strong>，同时实现数据冗余备份。</p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/197e2c59c438ede485bd9989d8e33e9d.png" alt="image-20210531151105863"></p>
<h2 id="9-1-单机redis的风险与问题"><a href="#9-1-单机redis的风险与问题" class="headerlink" title="9.1.单机redis的风险与问题"></a>9.1.单机redis的风险与问题</h2><p>问题1：机器故障<br>    现象：硬盘故障、系统崩溃<br>    本质：数据丢失，很可能对业务造成灾难性打击<br>    结论：基本上会放弃使用redis<br>问题2：容量瓶颈<br>    现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存<br>    本质：穷，硬件条件跟不上<br>    结论：放弃使用redis<br>结论： 为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续 提供服务，实现Redis的高可用，同时实现数据冗余备份。</p>
<h2 id="9-2-多台服务器连接方案"><a href="#9-2-多台服务器连接方案" class="headerlink" title="9.2.多台服务器连接方案"></a>9.2.多台服务器连接方案</h2><ul>
<li><p>提供数据方：master</p>
<pre><code>主服务器，主节点，主库（主客户端）
</code></pre>
</li>
<li><p>接收数据方：slave</p>
<pre><code>从服务器，从节点，从库（从客户端）
</code></pre>
</li>
<li><p>需要解决的问题： 数据同步</p>
</li>
<li><p>核心工作： master的数据复制到slave中</p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/1920a90c9788fed6355bbe5ce91c8d94.png" alt="image-20210531151942161"></p>
</li>
</ul>
<p>其中，为了避免数据产生大大小小的问题，我们需要对多台服务器的连接方案进行一些规定限制</p>
<p>主从复制即将master中的数据即时、有效的复制到slave中</p>
<p>特征：一个master可以拥有多个slave，一个slave只对应一个master</p>
<p>职责：</p>
<ul>
<li><p>master:</p>
<pre><code>写数据
执行写操作时，将出现变化的数据自动同步到slave
读数据（可忽略）
</code></pre>
</li>
<li><p>slave:</p>
<pre><code>读数据
写数据（禁止）
</code></pre>
</li>
</ul>
<h2 id="9-3-高可用集群"><a href="#9-3-高可用集群" class="headerlink" title="9.3.高可用集群"></a>9.3.高可用集群</h2><p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/291889f858f8fc2bad4c784d0f1ad6bf.png" alt="image-20210531152453098"></p>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ul>
<li>读写分离：master写、slave读，提高服务器的读写负载能力</li>
<li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li>
<li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>总述：大致上分为三个步骤</p>
<p>建立连接阶段（即准备阶段）<br>数据同步阶段<br>命令传播阶段</p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/4c43d58dc1998052e4674d976d5b10b0.png" alt="image-20210531153020881"></p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/3b18785535cca2c5164cda6a4025fb3a.png" alt="image-20210531153652475"></p>
<p>步骤1：设置master的地址和端口，保存master信息<br>步骤2：建立socket连接<br>步骤3：发送ping命令（定时器任务）<br>步骤4：身份验证<br>步骤5：发送slave端口信息 至此，主从连接成功！<br>状态：<br>slave： 保存master的地址与端口<br>master： 保存slave的端口<br>总体： 之间创建了连接的socket</p>
<h4 id="阶段一、主从连接（slave连接master）"><a href="#阶段一、主从连接（slave连接master）" class="headerlink" title="阶段一、主从连接（slave连接master）"></a>阶段一、主从连接（slave连接master）</h4><p>方式一：客户端发送命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>



<p>方式二：启动服务器参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>


<p>方式三：服务器配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

<p>slave系统信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master_link_down_since_seconds</span><br><span class="line">masterhost</span><br><span class="line">masterport </span><br></pre></td></tr></table></figure>



<p>master系统信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave_listening_port(多个)</span><br></pre></td></tr></table></figure>


<p>现在的启动方式一般不直接在从服务器上敲连接主服务器的命令，而是直接在从服务器的配置文件中添加对应的连接配置信息redis-6380.conf</p>
<p>关闭守护进程、关闭日志文件的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/99208f9242d7ced9e3c18cbbe139352c.png" alt="image-20210531155505870"></p>
<p>连接成功之后，可以在服务器的启动页面看到对应的连接master的相关信息</p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/8092bc718a2df0879e7f15b5af1bd964.png" alt="image-20210531155735351"></p>
<p>这样就简单完成了主从服务器的搭建，根据业务的建议逻辑，我们只在master中写入数据，而在slave中读取数据，这样可以有效地避免数据的同步的一些问题。</p>
<p>这样配置，就可以完成上述的操作了</p>
<p>在服务器端输入info指令，可以看到关于连接的一些信息</p>
<p>其他配置</p>
<p>客户端发送命令</p>
<p><code>slaveof no one</code></p>
<p>说明： slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</p>
<p>因为主服务器上可能存在多个连接，所以断开连接只能是在从服务器这一侧断开，也就是在从服务器的客户端发送断开指令，由主服务器接受指令之后，执行断开操作</p>
<p>授权访问</p>
<p>master客户端发送命令设置密码</p>
<p><code>config get requirepass  requirepass</code></p>
<p>master配置文件设置密码</p>
<p><code>config set requirepass</code></p>
<p>slave客户端发送命令设置密码</p>
<p><code>auth &lt;password&gt;</code></p>
<p>slave配置文件设置密码</p>
<p><code>masterauth &lt;password&gt;</code></p>
<p>slave启动服务器设置密码</p>
<p><code>redis-server –a &lt;password&gt;</code></p>
<h4 id="阶段二、数据同步阶段（master和slave数据同步）"><a href="#阶段二、数据同步阶段（master和slave数据同步）" class="headerlink" title="阶段二、数据同步阶段（master和slave数据同步）"></a>阶段二、数据同步阶段（master和slave数据同步）</h4><p>数据同步的过程目的分析</p>
<ul>
<li>在slave初次连接master后，复制master中的所有数据到slave</li>
<li>将slave的数据库状态更新成master当前的数据库状态</li>
</ul>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/7d27ee2e0e873e5d5317c223bc3a11aa.png" alt="image-20210531161531762"></p>
<p>数据同步整个过程为上图的1-8条，分为全量复制和部分复制（增量复制）</p>
<p>全量复制，主要复制的是master中从开始到连接状态完成之间的数据部分；这一部分主要使用的是RDB的形式恢复数据。</p>
<p>增量复制，主要复制的是全量复制过程中master可能产生的新数据，这些数据一般数据量不是非常大，主要利用AOF形式进行数据备份和恢复，这样更符合现实情况。这一阶段产生的新数据放在复制缓冲区内。</p>
<ul>
<li><p>步骤1：请求同步数据</p>
</li>
<li><p>步骤2：创建RDB同步数据</p>
</li>
<li><p>步骤3：恢复RDB同步数据</p>
</li>
<li><p>步骤4：请求部分同步数据</p>
</li>
<li><p>步骤5：恢复部分同步数据<br>至此，数据同步工作完成！</p>
</li>
<li><p>状态：</p>
<ul>
<li>slave： 具有master端全部数据，包含RDB过程接收的数据</li>
<li>master： 保存slave当前数据同步的位置</li>
</ul>
</li>
<li><p>总体： 之间完成了数据克隆</p>
</li>
</ul>
<h5 id="注意事项（master说明）"><a href="#注意事项（master说明）" class="headerlink" title="注意事项（master说明）"></a>注意事项（master说明）</h5><ol>
<li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p>
</li>
<li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p>
</li>
</ol>
<p><code>repl-backlog-size 1mb</code></p>
<p>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</p>
<p>这里涉及到的问题主要是复制缓冲区的内存大小，设置不合理要么导致全量复制阶段产生的新数据部分丢失（后产生的数据溢出就会挤掉最先产生的数据），要么导致还速度下降（复制缓冲区内存过大，导致分配给其他部分的内存太小，影响IO性能）</p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/65a94f35719900c82edfa7efee302888.png" alt="image-20210531162933595"></p>
<h5 id="注意事项（slave后期）"><a href="#注意事项（slave后期）" class="headerlink" title="注意事项（slave后期）"></a>注意事项（slave后期）</h5><ol>
<li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务、</p>
<p><code>slave-serve-stale-data yes|no</code></p>
</li>
<li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p>
</li>
<li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果 master带宽不足，因此数据同步需要根据业务需求，适量错峰</p>
</li>
<li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择</p>
</li>
</ol>
<p>这里的问题主要是：根据设计原理，关闭slave的对外写数据服务；slave数量过多时候如何处理slave的数据复制问题。</p>
<h4 id="阶段三：命令传播阶段"><a href="#阶段三：命令传播阶段" class="headerlink" title="阶段三：命令传播阶段"></a>阶段三：命令传播阶段</h4><p>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的 状态，同步的动作称为命令传播</p>
<p>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</p>
<p>主从复制过程大体可以分为3个阶段</p>
<ol>
<li><p>建立连接阶段（即准备阶段）</p>
</li>
<li><p>数据同步阶段</p>
</li>
<li><p>命令传播阶段</p>
</li>
</ol>
<h5 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h5><p>命令传播阶段出现了断网现象</p>
<ol>
<li>网络闪断闪连 忽略</li>
<li>短时间网络中断 部分复制</li>
<li>长时间网络中断 全量复制</li>
</ol>
<p>部分复制的三个核心要素</p>
<ol>
<li><p>服务器的运行 id（run id）</p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/7a578d4798b24da753478fd1ae19d122.png" alt="image-20210531163605924"></p>
</li>
<li><p>主服务器的复制积压缓冲区</p>
</li>
<li><p>主从服务器的复制偏移量</p>
</li>
</ol>
<h5 id="服务器运行ID（runid）"><a href="#服务器运行ID（runid）" class="headerlink" title="服务器运行ID（runid）"></a>服务器运行ID（runid）</h5><ul>
<li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li>
<li>组成：运行id由40位字符组成，是一个随机的十六进制字符；例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li>
<li>作用：运行id被用于在服务器间进行传输，识别身份 如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li>
<li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid</li>
</ul>
<h5 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h5><ul>
<li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区<br>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</li>
<li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区</li>
<li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</li>
<li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</li>
</ul>
<p>内部工作原理：</p>
<p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/51eb156981ab136d7fa9df43f954389f.png" alt="image-20210531164646455"></p>
<h5 id="主从服务器复制偏移量（offset）"><a href="#主从服务器复制偏移量（offset）" class="headerlink" title="主从服务器复制偏移量（offset）"></a>主从服务器复制偏移量（offset）</h5><ul>
<li>概念：一个数字，描述复制缓冲区中的指令字节位置</li>
<li>分类：<pre><code>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）
slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）
</code></pre>
</li>
<li>数据来源：<pre><code>master端：发送一次记录一次
slave端：接收一次记录一次
</code></pre>
</li>
<li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</li>
</ul>
<h5 id="数据同步-命令传播阶段工作流程"><a href="#数据同步-命令传播阶段工作流程" class="headerlink" title="数据同步+命令传播阶段工作流程"></a>数据同步+命令传播阶段工作流程</h5><p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/54f6cad86aab6e25fe622bc2fc794f4e.png" alt="image-20210531165411947"></p>
<h5 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h5><p>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</p>
<p>master心跳：<br>    指令：PING<br>    周期：由repl-ping-slave-period决定，默认10秒<br>    作用：判断slave是否在线<br>    查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常<br>slave心跳任务<br>    指令：REPLCONF ACK {offset}<br>    周期：1秒<br>    作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令<br>    作用2：判断master是否在线</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 2</span><br><span class="line">min-slaves-max-lag 8</span><br></pre></td></tr></table></figure>

<ul>
<li><p>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</p>
</li>
<li><p>slave数量由slave发送REPLCONF ACK命令做确认</p>
</li>
<li><p>slave延迟由slave发送REPLCONF ACK命令做确认</p>
</li>
</ul>
<h5 id="主从复制工作流程"><a href="#主从复制工作流程" class="headerlink" title="主从复制工作流程"></a>主从复制工作流程</h5><p><img src="https://gitee.com/wyl1924/cdn/raw/master/img/blog/b590f9dfbf30a2d6e12908e11d6e759c.png" alt="image-20210531170127664"></p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="频繁的全量复制（1）"><a href="#频繁的全量复制（1）" class="headerlink" title="频繁的全量复制（1）"></a>频繁的全量复制（1）</h5><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作</p>
<ul>
<li><p>内部优化调整方案：</p>
<pre><code>    master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave
</code></pre>
</li>
<li><p>在master关闭时执行命令 shutdown save，进行RDB持久化，将runid与offset保存到RDB文件中</p>
<pre><code>1.repl-id repl-offset
</code></pre>
<p>​    2.通过redis-check-rdb命令可以查看该信息</p>
</li>
<li><p>master重启后加载RDB文件，恢复数据重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中</p>
<pre><code>1.master_repl_id = repl master_repl_offset = repl-offset
</code></pre>
<p>​    2.通过info命令可以查看该信息</p>
</li>
</ul>
<p>作用： 本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</p>
<h5 id="频繁的全量复制（2）"><a href="#频繁的全量复制（2）" class="headerlink" title="频繁的全量复制（2）"></a>频繁的全量复制（2）</h5><p>问题现象：网络环境不佳，出现网络中断，slave不提供服务</p>
<p>问题原因：复制缓冲区过小，断网后slave的offset越界，触发全量复制</p>
<p>最终结果：slave反复进行全量复制</p>
<p>解决方案：修改复制缓冲区大小</p>
<p><code>repl-backlog-size</code></p>
<p>建议设置如下：</p>
<ol>
<li>测算从master到slave的重连平均时长second</li>
<li>获取master平均每秒产生写命令数据总量write_size_per_second</li>
<li>最优复制缓冲区空间 = 2 * second * write_size_per_second</li>
</ol>
<h5 id="频繁的网络中断（1）"><a href="#频繁的网络中断（1）" class="headerlink" title="频繁的网络中断（1）"></a>频繁的网络中断（1）</h5><p>问题现象：master的CPU占用过高 或 slave频繁断开连接</p>
<p>问题原因：</p>
<ul>
<li>slave每1秒发送REPLCONF ACK命令到master</li>
<li>当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能</li>
<li>master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</li>
</ul>
<p>最终结果：master各种资源（输出缓冲区、带宽、连接等）被严重占用</p>
<p>解决方案：通过设置合理的超时时间，确认是否释放slave 该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</p>
<h5 id="频繁的网络中断（2）"><a href="#频繁的网络中断（2）" class="headerlink" title="频繁的网络中断（2）"></a>频繁的网络中断（2）</h5><p>问题现象：slave与master连接断开</p>
<p>问题原因：</p>
<ul>
<li>master发送ping指令频度较低</li>
<li>master设定超时时间较短</li>
<li>ping指令在网络中存在丢包</li>
</ul>
<p>解决方案：</p>
<p>​    提高ping指令发送的频度</p>
<p>```repl-ping-slave-period``</p>
<p>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</p>
<h5 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h5><p>问题现象：多个slave获取相同数据不同步</p>
<p>问题原因：网络信息不同步，数据发送有延迟</p>
<p>解决方案：</p>
<p>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</p>
<p>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问</p>
<p><code>slave-serve-stale-data yes|no</code><br>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）</p>
<h1 id="10-哨兵模式"><a href="#10-哨兵模式" class="headerlink" title="10.哨兵模式"></a>10.哨兵模式</h1><p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的 master并将所有slave连接到新的master。</p>
<p>哨兵的作用：</p>
<ul>
<li><p>监控     不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测。</p>
</li>
<li><p>通知（提醒）  当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</p>
</li>
<li><p>自动故障转移    断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址。</p>
<p>哨兵也是一台redis服务器，只是不提供数据服务。通常哨兵配置数量为单数</p>
</li>
</ul>
<h1 id="11-cluster"><a href="#11-cluster" class="headerlink" title="11.cluster"></a>11.cluster</h1><p>集群：集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果。</p>
<p>集群作用：</p>
<ul>
<li>分散单台服务器的访问压力，实现负载均衡。</li>
<li>分散单台服务器的存储压力，实现可扩展性。</li>
<li>降低单台服务器宕机带来的业务灾难。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cluster配置</span><br><span class="line">cluster-enabled yes|no               添加节点</span><br><span class="line">cluster-config-file &lt;filename&gt;       cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</span><br><span class="line">cluster-node-timeout &lt;milliseconds&gt;  节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</span><br><span class="line">cluster-migration-barrier &lt;count&gt;    master连接的slave最小数量</span><br><span class="line"></span><br><span class="line">cluster节点操作</span><br><span class="line">cluster nodes                        查看集群节点信息</span><br><span class="line">cluster replicate &lt;master-id&gt;        进入一个从节点 redis，切换其主节点</span><br><span class="line">cluster meet ip:port                 发现一个新节点，新增主节点</span><br><span class="line">cluster forget &lt;id&gt;                  忽略一个没有solt的节点</span><br><span class="line">cluster failover                     手动故障转移</span><br><span class="line"></span><br><span class="line">redis-trib命令</span><br><span class="line">redis-trib.rb add-node               添加节点</span><br><span class="line">redis-trib.rb del-node               删除节点</span><br><span class="line">redis-trib.rb reshard                重新分片</span><br></pre></td></tr></table></figure>

<h1 id="12企业级解决方案"><a href="#12企业级解决方案" class="headerlink" title="12企业级解决方案"></a>12企业级解决方案</h1><h2 id="1-缓存预热"><a href="#1-缓存预热" class="headerlink" title="1.缓存预热"></a>1.缓存预热</h2><p>问题排查：</p>
<ol>
<li>请求数量较高</li>
<li>主从之间数据吞吐量较大，数据同步操作频度较高</li>
</ol>
<p>解决方案：</p>
<ul>
<li><p>前置准备工作：</p>
<ul>
<li>日常例行统计数据访问记录，统计访问频度较高的热点数据。</li>
<li>利用LRU数据删除策略，构建数据留存队列。   例如：storm与kafka配合</li>
</ul>
</li>
<li><p>准备工作：</p>
<ul>
<li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li>
<li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li>
<li>热点数据主从同时预热</li>
</ul>
</li>
<li><p>实施：</p>
<ul>
<li>使用脚本程序固定触发数据预热过程。</li>
<li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</li>
</ul>
</li>
</ul>
<h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><p>问题排查：</p>
<ol>
<li> <strong>在一个较短的时间内，缓存中较多的key集中过期</strong></li>
<li> 数据库同时接收到大量的请求无法及时处理</li>
<li> Redis服务器资源被严重占用，Redis服务器崩溃</li>
</ol>
<p>解决方案：</p>
<ul>
<li><p>思路</p>
<ul>
<li><p>更多的页面静态化处理</p>
</li>
<li><p>构建多级缓存架构     Nginx缓存+redis缓存+ehcache缓存</p>
</li>
<li><p>检测Mysql严重耗时业务进行优化     对数据库的瓶颈排查：例如超时查询、耗时较高事务等</p>
</li>
<li><p>灾难预警机制：监控redis服务器性能指标</p>
<ul>
<li>CPU占用、CPU使用率</li>
<li>内存容量</li>
<li>查询平均响应时间</li>
<li>线程数</li>
</ul>
</li>
<li><p>限流、降级    短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</p>
</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><p>LRU与LFU切换</p>
</li>
<li><p>数据有效期策略调整</p>
<ul>
<li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</li>
<li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li>
</ul>
</li>
<li><p> 超热数据使用永久key</p>
</li>
<li><p>定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</p>
</li>
<li><p>加锁（慎用）</p>
</li>
</ul>
</li>
<li><p>总结：缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p>
</li>
</ul>
<h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3.缓存击穿"></a>3.缓存击穿</h2><ul>
<li><p>问题排查：</p>
<ul>
<li>Redis中某个key过期，该key访问量巨大</li>
<li>多个数据请求从服务器直接压到Redis后，均未命中</li>
<li>Redis在短时间内发起了大量对数据库中同一数据的访问</li>
</ul>
</li>
<li><p>问题分析</p>
<ul>
<li>单个key高热数据</li>
<li> key过期</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>预先设定</p>
<p>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长。   注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p>
</li>
<li><p>现场调整     监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</p>
</li>
<li><p>后台刷新数据     启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</p>
</li>
<li><p>二级缓存     设置不同的失效时间，保障不会被同时淘汰就行</p>
</li>
<li><p>加锁      分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</p>
</li>
</ul>
</li>
<li><p>总结：缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度 较高，配合雪崩处理策略即可。</p>
</li>
</ul>
<h2 id="4-缓存穿透"><a href="#4-缓存穿透" class="headerlink" title="4.缓存穿透"></a>4.缓存穿透</h2><ul>
<li><p>问题排查：</p>
<ul>
<li>Redis中大面积出现未命中</li>
<li> 出现非正常URL访问</li>
</ul>
</li>
<li><p>问题分析：</p>
<ul>
<li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li>
<li> Redis获取到null数据未进行持久化，直接返回</li>
<li> 下次此类数据到达重复上述过程</li>
<li>出现黑客攻击服务器</li>
</ul>
</li>
<li><p>解决方案：</p>
<ul>
<li><p>缓存null     对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</p>
</li>
<li><p>白名单策略：</p>
<ul>
<li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）</li>
<li>使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</li>
</ul>
</li>
<li><p>实施监控     实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比</p>
<ul>
<li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</li>
<li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象 根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li>
</ul>
</li>
<li><p>key加密     问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验。例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</p>
</li>
<li><p>总结：缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。 无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除</p>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">王延领</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jingmo1924.cn/2022/03/28/java/secondstage/redis/">http://jingmo1924.cn/2022/03/28/java/secondstage/redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jingmo1924.cn" target="_blank">王延领的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/">双机热备</a><a class="post-meta__tags" href="/tags/linux/">linux</a></div><div class="post_share"><div class="social-share" data-image="/images/2022072501.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/05/java/secondstage/java%E9%AB%98%E5%B9%B6%E5%8F%91/"><img class="prev-cover" src="/images/20221004.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">多线程</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/25/Linux/linux%E6%8B%89%E5%8F%96%E9%83%A8%E7%BD%B2git%E4%B8%8A%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%B0docker/"><img class="next-cover" src="/images/20220725.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">linux拉取部署git上的项目到docker</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/07/Linux/linux 双机热备/" title="linux双机热备"><img class="cover" src="/images/20211111.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-07</div><div class="title">linux双机热备</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">王延领</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wyl1924"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wyl1924" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://1714404171@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-Redis%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">0.Redis介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Redis-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">1.Redis 的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">1.1.安装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">2.Redis基本数据存储类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1String%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">2.1String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">3.1.3.</span> <span class="toc-text">业务场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E8%AE%A1%E6%95%B0"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">常规计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB-Session-%E4%BF%A1%E6%81%AF"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">共享 Session 信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2.2Hash类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">业务场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">缓存对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3List"><span class="toc-number">3.3.</span> <span class="toc-text">2.3List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4set%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">2.4set类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">3.4.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">3.4.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">3.4.3.</span> <span class="toc-text">应用场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">点赞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">共同关注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E5%A5%96%E6%B4%BB%E5%8A%A8"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">抽奖活动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5sorted-set%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">2.5sorted_set类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"><span class="toc-number">3.5.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-number">3.5.2.</span> <span class="toc-text">业务场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6geo-%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">2.6geo 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">3.6.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-5"><span class="toc-number">3.6.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">3.6.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7HyperLogLog"><span class="toc-number">3.7.</span> <span class="toc-text">2.7HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">3.7.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">3.7.2.</span> <span class="toc-text">常见命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">3.7.3.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BE%E4%B8%87%E7%BA%A7%E7%BD%91%E9%A1%B5-UV-%E8%AE%A1%E6%95%B0"><span class="toc-number">3.7.3.1.</span> <span class="toc-text">百万级网页 UV 计数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8Bitmap"><span class="toc-number">3.8.</span> <span class="toc-text">2.8Bitmap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">3.8.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-6"><span class="toc-number">3.8.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">3.8.3.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.8.3.1.</span> <span class="toc-text">签到统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E6%80%81"><span class="toc-number">3.8.3.2.</span> <span class="toc-text">判断用户登陆态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0%E7%94%A8%E6%88%B7%E6%80%BB%E6%95%B0"><span class="toc-number">3.8.3.3.</span> <span class="toc-text">连续签到用户总数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9Zset"><span class="toc-number">3.9.</span> <span class="toc-text">2.9Zset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">3.9.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-7"><span class="toc-number">3.9.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">3.9.3.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">3.9.3.1.</span> <span class="toc-text">排行榜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E3%80%81%E5%A7%93%E5%90%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">3.9.3.2.</span> <span class="toc-text">电话、姓名排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-Stream"><span class="toc-number">3.10.</span> <span class="toc-text">2.10 Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-Stream-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">3.10.1.</span> <span class="toc-text">Redis Stream 相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.10.1.1.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">3.10.1.2.</span> <span class="toc-text">消费者组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-Stream-%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90"><span class="toc-number">3.10.2.</span> <span class="toc-text">Redis Stream 命令解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xadd-%E6%B7%BB%E5%8A%A0%E6%B6%88%E6%81%AF"><span class="toc-number">3.10.2.1.</span> <span class="toc-text">xadd 添加消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xtrim-%E4%BF%AE%E5%89%AA%E6%B5%81"><span class="toc-number">3.10.2.2.</span> <span class="toc-text">xtrim 修剪流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xlen-%E6%B5%81%E9%95%BF%E5%BA%A6"><span class="toc-number">3.10.2.3.</span> <span class="toc-text">xlen 流长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xdel-%E5%88%A0%E9%99%A4%E6%B6%88%E6%81%AF"><span class="toc-number">3.10.2.4.</span> <span class="toc-text">xdel 删除消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xrange-%E6%B6%88%E6%81%AF%E5%88%97%E8%A1%A8"><span class="toc-number">3.10.2.5.</span> <span class="toc-text">xrange 消息列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xrevrange-%E6%B6%88%E6%81%AF%E5%88%97%E8%A1%A8"><span class="toc-number">3.10.2.6.</span> <span class="toc-text">xrevrange 消息列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xread-%E6%B6%88%E6%81%AF%E5%88%97%E8%A1%A8"><span class="toc-number">3.10.2.7.</span> <span class="toc-text">xread 消息列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xgroup-create-%E5%88%9B%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">3.10.2.8.</span> <span class="toc-text">xgroup create 创建消费者组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xreadgroup-group-%E8%AF%BB%E5%8F%96%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%B6%88%E6%81%AF"><span class="toc-number">3.10.2.9.</span> <span class="toc-text">xreadgroup group 读取消费者组消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xpending-%E5%BE%85%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">3.10.2.10.</span> <span class="toc-text">xpending 待处理消息信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81xack-%E6%B6%88%E6%81%AF%E6%A0%87%E8%AE%B0"><span class="toc-number">3.10.2.11.</span> <span class="toc-text">11、xack 消息标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xgroup-setid-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E8%AE%BE%E7%BD%AE%E6%96%B0%E7%9A%84%E6%9C%80%E5%90%8E%E9%80%92%E9%80%81%E6%B6%88%E6%81%AFID"><span class="toc-number">3.10.2.12.</span> <span class="toc-text">xgroup setid 消费者组设置新的最后递送消息ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xgroup-delconsumer-%E5%88%A0%E9%99%A4%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">3.10.2.13.</span> <span class="toc-text">xgroup delconsumer 删除消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xgroup-destroy-%E5%88%A0%E9%99%A4%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">3.10.2.14.</span> <span class="toc-text">xgroup destroy 删除消费者组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xclaim-%E8%BD%AC%E7%A7%BB%E6%B6%88%E6%81%AF%E5%BD%92%E5%B1%9E%E6%9D%83"><span class="toc-number">3.10.2.15.</span> <span class="toc-text">xclaim 转移消息归属权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xinfo-%E6%B5%81%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E4%BF%A1%E6%81%AF"><span class="toc-number">3.10.2.16.</span> <span class="toc-text">xinfo 流和消费者组信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xinfo-groups-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">3.10.2.17.</span> <span class="toc-text">xinfo groups 消费者组的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xinfo-stream-%E6%B5%81%E4%BF%A1%E6%81%AF"><span class="toc-number">3.10.2.18.</span> <span class="toc-text">xinfo stream 流信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11%E6%80%BB%E7%BB%93"><span class="toc-number">3.10.3.</span> <span class="toc-text">2.11总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">3.通用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1key%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">3.1key通用指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">4.2.</span> <span class="toc-text">3.2数据库通用指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">4.redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">4.1RDB持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2AOP%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">4.2AOP持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.3.</span> <span class="toc-text">4.3混合持久化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.</span> <span class="toc-text">5.redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E4%BA%8B%E5%8A%A1%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">6.1.</span> <span class="toc-text">5.1事务基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E9%94%81"><span class="toc-number">6.2.</span> <span class="toc-text">5.2锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E5%9F%BA%E4%BA%8E%E7%89%B9%E5%AE%9A%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">6.3.</span> <span class="toc-text">5.3基于特定事务执行——分布式锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-redis%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">7.</span> <span class="toc-text">6.redis删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.</span> <span class="toc-text">6.1数据删除策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4"><span class="toc-number">7.2.</span> <span class="toc-text">1.定时删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="toc-number">7.3.</span> <span class="toc-text">2.惰性删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%EF%BC%88%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%9F%A5%EF%BC%8C%E9%87%8D%E7%82%B9%E6%8A%BD%E6%9F%A5%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">3.定期删除（随机抽查，重点抽查）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E9%80%90%E5%87%BA%E7%AE%97%E6%B3%95"><span class="toc-number">7.5.</span> <span class="toc-text">6.2逐出算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-redis%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE"><span class="toc-number">8.</span> <span class="toc-text">7.redis核心配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">8.高级数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1Bitmaps"><span class="toc-number">9.1.</span> <span class="toc-text">8.1Bitmaps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2HyperLogLog"><span class="toc-number">9.2.</span> <span class="toc-text">8.2HyperLogLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3GEO"><span class="toc-number">9.3.</span> <span class="toc-text">8.3GEO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">9.主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%8D%95%E6%9C%BAredis%E7%9A%84%E9%A3%8E%E9%99%A9%E4%B8%8E%E9%97%AE%E9%A2%98"><span class="toc-number">10.1.</span> <span class="toc-text">9.1.单机redis的风险与问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E6%A1%88"><span class="toc-number">10.2.</span> <span class="toc-text">9.2.多台服务器连接方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4"><span class="toc-number">10.3.</span> <span class="toc-text">9.3.高可用集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">10.3.1.</span> <span class="toc-text">主从复制的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">10.3.2.</span> <span class="toc-text">工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">10.3.2.1.</span> <span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%E3%80%81%E4%B8%BB%E4%BB%8E%E8%BF%9E%E6%8E%A5%EF%BC%88slave%E8%BF%9E%E6%8E%A5master%EF%BC%89"><span class="toc-number">10.3.2.2.</span> <span class="toc-text">阶段一、主从连接（slave连接master）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%98%B6%E6%AE%B5%EF%BC%88master%E5%92%8Cslave%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%EF%BC%89"><span class="toc-number">10.3.2.3.</span> <span class="toc-text">阶段二、数据同步阶段（master和slave数据同步）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88master%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="toc-number">10.3.2.3.1.</span> <span class="toc-text">注意事项（master说明）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88slave%E5%90%8E%E6%9C%9F%EF%BC%89"><span class="toc-number">10.3.2.3.2.</span> <span class="toc-text">注意事项（slave后期）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E9%98%B6%E6%AE%B5"><span class="toc-number">10.3.2.4.</span> <span class="toc-text">阶段三：命令传播阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E9%98%B6%E6%AE%B5%E7%9A%84%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6"><span class="toc-number">10.3.2.4.1.</span> <span class="toc-text">命令传播阶段的部分复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8CID%EF%BC%88runid%EF%BC%89"><span class="toc-number">10.3.2.4.2.</span> <span class="toc-text">服务器运行ID（runid）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">10.3.2.4.3.</span> <span class="toc-text">复制缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%8D%E5%88%B6%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%88offset%EF%BC%89"><span class="toc-number">10.3.2.4.4.</span> <span class="toc-text">主从服务器复制偏移量（offset）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5-%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E9%98%B6%E6%AE%B5%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">10.3.2.4.5.</span> <span class="toc-text">数据同步+命令传播阶段工作流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">10.3.2.4.6.</span> <span class="toc-text">心跳机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.3.2.4.7.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">10.3.2.4.8.</span> <span class="toc-text">主从复制工作流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">10.3.2.5.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%91%E7%B9%81%E7%9A%84%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%EF%BC%881%EF%BC%89"><span class="toc-number">10.3.2.5.1.</span> <span class="toc-text">频繁的全量复制（1）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%91%E7%B9%81%E7%9A%84%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%EF%BC%882%EF%BC%89"><span class="toc-number">10.3.2.5.2.</span> <span class="toc-text">频繁的全量复制（2）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%91%E7%B9%81%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%EF%BC%881%EF%BC%89"><span class="toc-number">10.3.2.5.3.</span> <span class="toc-text">频繁的网络中断（1）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%91%E7%B9%81%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%EF%BC%882%EF%BC%89"><span class="toc-number">10.3.2.5.4.</span> <span class="toc-text">频繁的网络中断（2）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">10.3.2.5.5.</span> <span class="toc-text">数据不一致</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">10.哨兵模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-cluster"><span class="toc-number">12.</span> <span class="toc-text">11.cluster</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">13.</span> <span class="toc-text">12企业级解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">13.1.</span> <span class="toc-text">1.缓存预热</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">13.2.</span> <span class="toc-text">2.缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">13.3.</span> <span class="toc-text">3.缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">13.4.</span> <span class="toc-text">4.缓存穿透</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/05/Linux/linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="linux 常用命令"><img src="/images/2020072502.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux 常用命令"/></a><div class="content"><a class="title" href="/2022/07/05/Linux/linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="linux 常用命令">linux 常用命令</a><time datetime="2022-07-05T08:22:21.000Z" title="发表于 2022-07-05 16:22:21">2022-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/07/Linux/linux%20%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/" title="linux双机热备"><img src="/images/20211111.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux双机热备"/></a><div class="content"><a class="title" href="/2022/06/07/Linux/linux%20%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/" title="linux双机热备">linux双机热备</a><time datetime="2022-06-07T08:51:47.683Z" title="发表于 2022-06-07 16:51:47">2022-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/07/Linux/linux%E4%B8%ADservice%E6%96%87%E4%BB%B6/" title="linux中service 文件"><img src="/images/2022072503.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux中service 文件"/></a><div class="content"><a class="title" href="/2022/06/07/Linux/linux%E4%B8%ADservice%E6%96%87%E4%BB%B6/" title="linux中service 文件">linux中service 文件</a><time datetime="2022-06-07T08:38:16.983Z" title="发表于 2022-06-07 16:38:16">2022-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/java/secondstage/SpringCode/" title="Spring Cloud"><img src="/images/20211109.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/2022/04/05/java/secondstage/SpringCode/" title="Spring Cloud">Spring Cloud</a><time datetime="2022-04-05T08:22:21.000Z" title="发表于 2022-04-05 16:22:21">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/java/secondstage/java%E9%AB%98%E5%B9%B6%E5%8F%91/" title="多线程"><img src="/images/20221004.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程"/></a><div class="content"><a class="title" href="/2022/04/05/java/secondstage/java%E9%AB%98%E5%B9%B6%E5%8F%91/" title="多线程">多线程</a><time datetime="2022-04-05T08:22:21.000Z" title="发表于 2022-04-05 16:22:21">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 王延领</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>